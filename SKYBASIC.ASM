; *** Generated by G.Dar Z80 compiler v1.12 on 01/12/94

title "skybasic.c"

public	_DirectBuf
public	_TextP
public	_PrgBase
public	_VarBase
public	_VarEnd
public	_StrBase
public	_MemTop
public	_DirectMode
public	_fError
public	_Linea
public	_KeyWords
public	_Funct
public	_Errore
public	_BitTable
extrn	_printf
extrn	_puts
extrn	_scanf
extrn	_abs
extrn	_labs
extrn	_atoi
extrn	_atol
extrn	_rand
extrn	_srand
extrn	_malloc
extrn	_memmove
extrn	_strcpy
extrn	_strlen
extrn	_strncmp
extrn	_strnicmp
extrn	__ctype
extrn	_getch
extrn	_inp
extrn	_outp
extrn	_kbhit
extrn	_putch
extrn	_isBreak
extrn	_clock
extrn	_sin
extrn	_cos
extrn	_tan
extrn	_sqrt
extrn	_exp
extrn	_log
extrn	_pow
extrn	__lmul
extrn	_cursOn
extrn	_cursOff
extrn	_cls
extrn	__ldiv
;
	dsect	bss
_KeyWords
 dw	L00001
 dw	L00002
 dw	L00003
 dw	L00004
 dw	L00005
 dw	L00006
 dw	L00007
 dw	L00008
 dw	L00009
 dw	L00010
 dw	L00011
 dw	L00012
 dw	L00013
 dw	L00014
 dw	L00015
 dw	L00016
 dw	L00017
 dw	L00018
 dw	L00019
 dw	L00020
 dw	L00021
 dw	L00022
 dw	L00023
 dw	L00024
 dw	L00025
 dw	L00026
 dw	L00027
 dw	L00028
 dw	0
  ;KeyWords
_Funct
 dw	L00029
 dw	L00030
 dw	L00031
 dw	L00032
 dw	L00033
 dw	L00034
 dw	L00035
 dw	L00036
 dw	L00037
 dw	L00038
 dw	L00039
 dw	L00040
 dw	L00041
 dw	L00042
 dw	L00043
 dw	L00044
 dw	L00045
 dw	L00046
 dw	L00047
 dw	L00048
 dw	L00049
 dw	L00050
 dw	L00051
 dw	L00052
 dw	L00053
 dw	0
  ;Funct
_Errore
 dw	L00054
 dw	L00055
 dw	L00056
 dw	L00057
 dw	L00058
 dw	L00059
 dw	L00060
 dw	L00061
 dw	L00062
 dw	L00063
 dw	L00064
 dw	L00065
 dw	L00066
 dw	L00067
 dw	L00068
 dw	L00069
 dw	L00070
  ;Errore
_BitTable
 db	128
 db	64
 db	32
 db	16
 db	8
 db	4
 db	2
 db	1
  ;BitTable
;
	dsect	const
L00001 db "SYSTEM",0
L00002 db "NEW",0
L00003 db "LIST",0
L00004 db "RUN",0
L00005 db "END",0
L00006 db "STOP",0
L00007 db "PRINT",0
L00008 db "REM",0
L00009 db "FOR",0
L00010 db "TO",0
L00011 db "STEP",0
L00012 db "NEXT",0
L00013 db "GOTO",0
L00014 db "GOSUB",0
L00015 db "RETURN",0
L00016 db "IF",0
L00017 db "THEN",0
L00018 db "ELSE",0
L00019 db "ON",0
L00020 db "CALL",0
L00021 db "POKE",0
L00022 db "OUTP",0
L00023 db "INPUT",0
L00024 db "GET",0
L00025 db "CLS",0
L00026 db "BEEP",0
L00027 db "SAVE",0
L00028 db "LOAD",0
L00029 db "AND",0
L00030 db "OR",0
L00031 db "NOT",0
L00032 db "SGN",0
L00033 db "ABS",0
L00034 db "INT",0
L00035 db "SQR",0
L00036 db "SIN",0
L00037 db "COS",0
L00038 db "TAN",0
L00039 db "LOG",0
L00040 db "EXP",0
L00041 db "FRE",0
L00042 db "RND",0
L00043 db "PEEK",0
L00044 db "INP",0
L00045 db "LEN",0
L00046 db "STR$",0
L00047 db "VAL",0
L00048 db "CHR$",0
L00049 db "ASC",0
L00050 db "MID$",0
L00051 db "INSTR",0
L00052 db "TAB",0
L00053 db "DIN",0
L00054 db "Errore di sintassi",0
L00055 db "Valore non valido",0
L00056 db "Riga indefinita",0
L00057 db "Tipo non corrispondente",0
L00058 db "RETURN senza GOSUB",0
L00059 db "NEXT senza FOR",0
L00060 db "Fine memoria",0
L00061 db "Stringa troppo lunga",0
L00062 db 0
L00063 db 0
L00064 db 0
L00065 db 0
L00066 db 0
L00067 db 0
L00068 db 0
L00069 db 0
L00070 db "Fermo",0
L00071 db 10,"SkyBasic v%d.%02d (C) ADPM Synthesis 1994",10,0
L00072 db "%d bytes liberi",0
L00075 db 10,"Pronto.",0
L00139 db "%u ",0
L00151 db "%d",0
L00152 db "%ld",0
L00176 db "%s",0
L00303 db " alla linea %u",10,0
;
	dsect	data
_DirectBuf	db 80 dup (?)
	 ;DirectBuf
_TextP	dw 0 ;TextP
_PrgBase	dw 0 ;PrgBase
_VarBase	dw 0 ;VarBase
_VarEnd	dw 0 ;VarEnd
_StrBase	dw 0 ;StrBase
_MemTop	dw 0 ;MemTop
_DirectMode	db 1 ;DirectMode
_fError	db 0 ;fError
_Linea	dw 0 ;Linea

	cseg
; |>>> typedef unsigned int size_t|

; |>>> typedef char *va_list;

; |--- char *gets(char *);
; |--- int printf(char *,...);
; |--- int puts(char *);
; |--- int sprintf(char *, char *,`
; |--- int sscanf(char *, char *, `
; |--- int scanf(char *, ...);
; |--- int vfprintf(int, char *, v`
; |--- int vprintf(char *, va_list`
; |--- int vsprintf(char *, char *`
; |--- char getchar();
; |--- char putchar(char);
; |--- void beep(char);
; |--- double atof(char *);
; |--- double strtod(char *, char `
; |--- int abs(int);
; |--- long labs(long);
; |--- int atoi(char *);
; |--- long atol(char *);
; |--- char *itoa(int, char *, int`
; |--- char *ltoa(long, char *, in`
; |--- void exit(int);
; |--- int rand(void);
; |--- void srand(unsigned int);
; |--- void *malloc(size_t);
; |--- void *calloc(size_t, size_t`
; |--- void free(void *);
; |--- void *memmove(void *, void `
; |--- void *memccpy(void *, void `
; |--- void *memchr(void *, int, s`
; |--- int memcmp(void *, void *, `
; |--- void *memcpy(void *, void *`
; |--- int memicmp(void *, void *,`
; |--- void *memset(void *, int , `
; |--- char *strcat(char *, char *`
; |--- char *strchr(char *, int);`
; |--- char strcmp(char *, char *)`
; |--- char strcmpi(char *, char *`
; |--- char stricmp(char *, char *`
; |--- char *strcpy(char *, char *`
; |--- char *strdup(char *);
; |--- size_t strlen(char *);
; |--- char *strlwr(char *);     `
; |--- char *strncat(char *, char `
; |--- char strncmp(char *, char *`
; |--- char strnicmp(char *, char `
; |--- char *strncpy(char *, char `
; |--- char *strnset(char *, int, `
; |--- char *strrchr(char *, int);`
; |--- char *strrev(char *);      `
; |--- char *strset(char *, int); `
; |--- char *strstr(char *, char *`
; |--- char *strtok(char *, char *`
; |--- char *strupr(char *);
; |--- extern unsigned char _ctype`
; |--- char toascii(char);
; |--- char tolower(char);
; |--- char toupper(char);
; |--- char getch(void);
; |--- unsigned char inp(unsigned `
; |--- unsigned char outp(unsigned`
; |--- char kbhit(void);
; |--- char putch(char);
; |--- char ungetch(char);
; |--- char isBreak(void);
; |--- void doComm(void);
; |>>> typedef int time_t;    

; |>>> typedef int clock_t;    

; |--- clock_t clock(void);
; |--- char *_strtime(char *);
; |--- char *_strdate(char *);
; |--- time_t time(time_t *);
; |--- struct complex {
; |--- int abs(int);
; |--- long labs(long);
; |--- int sin(int);
; |--- int cos(int);
; |--- int tan(int);
; |--- int sqrt(int);
; |--- int exp(int);
; |--- int log(int);
; |--- int pow(int,int);
; |--- char DirectBuf[80];
; |--- char *TextP;
; |--- char *PrgBase,*VarBase,*Var`
; |--- char DirectMode=1;
; |--- char fError=0;
; |--- int Linea;
; |--- char ExecLine(void);
; |--- char ExecStmt(char);
; |--- char *CercaLine(int, char);`
; |--- long EvalExpr(char, char *)`
; |--- long GetValue(char);
; |--- char DoCheck(char);
; |--- char *CercaFine(char);
; |--- void SkipSpaces();
; |--- char CheckMemory(int);
; |--- char *AllocaString(int);
; |--- char *KeyWords[]={
; |--- char *Funct[]={
; |--- char *Errore[]={
; |--- char BitTable[8]={ 0x80,0x4`
; |--- int main() {

public	_main
_main	proc
	push	iy
	ld	iy,0
	add	iy,sp
	push	af
	push	af
	push	af
; |--- char Exit=0;
; Exit = -1
	ld	(iy-1),0		; Exit
; |--- int t;
; t = -4
; |--- char i,d;
; i = -5
; d = -6
; --------------------------------|
; |>>> PrgBase=malloc(0x1800);
	ld	hl,6144
	push	hl
	call	_malloc
	pop	af
	ld	(_PrgBase),hl		; PrgBase
; |>>> MemTop=PrgBase+0x1800;
	ld	hl,(_PrgBase)		; PrgBase
	ld	a,h
	add	a,24
	ld	h,a
	ld	(_MemTop),hl		; MemTop
; |>>> ExecStmt('\x81');          |
	ld	l,129
	push	hl
	call	_ExecStmt
	pop	af
ColdStart_main:
; |>>> printf("\nSkyBasic v%d.%02d¤
	ld	hl,1
	push	hl
	ld	hl,1
	push	hl
	ld	hl,L00071
	push	hl
	call	_printf
	pop	af
	pop	af
	pop	af
; |>>> printf("%d bytes liberi",Me¤
	ld	hl,(_MemTop)		; MemTop
	ld	de,(_PrgBase)		; PrgBase
	or	a
	sbc	hl,de
	push	hl
	ld	hl,L00072
	push	hl
	call	_printf
	pop	af
	pop	af
; |>>> d=1;
	ld	(iy-6),1		; d
WarmStart_main:
; |>>> do {
J00073:
; |>>> DirectMode=1;
	ld	l,1
	ld	a,l
	ld	(_DirectMode),a		; DirectMode
; |>>> fError=0;
	xor	a
	ld	l,a
	ld	a,l
	ld	(_fError),a		; fError
; |>>> TextP=DirectBuf;
	ld	hl,_DirectBuf		; DirectBuf
	ld	(_TextP),hl		; TextP
; |>>> if(d)
	ld	a,(iy-6)		; d
	or	a
	jp	z,L00074
; |>>> puts("\nPronto.");
	ld	hl,L00075
	push	hl
	call	_puts
	pop	af
L00074:
; |>>> GetLine();
	call	_GetLine
; |>>> t=Tokenize();
	call	_Tokenize
	ld	(iy-4),l
	ld	(iy-3),h		; t
; |>>> if(*TextP >= '0' && *TextP |
	ld	hl,(_TextP)		; TextP
	ld	l,(hl)
	ld	a,l
	cp	48
	jp	m,L00076
	ld	hl,(_TextP)		; TextP
	ld	l,(hl)
	ld	a,l
	cp	57
	jr	z,$+5
	jp	p,L00076
; |>>> StoreLine(t);
	ld	l,(iy-4)
	ld	h,(iy-3)		; t
	push	hl
	call	_StoreLine
	pop	af
; |>>> d=0;
	ld	(iy-6),0		; d
; |>>> else {
	jp	E00076
L00076:
; |>>> i=ExecLine();
	call	_ExecLine
	ld	(iy-5),l		; i
; |>>> if(i<0) {
	ld	a,(iy-5)
	or	a
	jp	p,L00077
; |>>> if(i==-1)
	ld	a,(iy-5)
	cp	255
	jp	nz,L00078
; |>>> Exit=1;
	ld	(iy-1),1		; Exit
	jp	E00078
L00078:
; |>>> else
; |>>> i=-i;
	ld	l,(iy-5)		; i
	ld	a,l
	neg
	ld	l,a
	ld	(iy-5),l		; i
E00078:
L00077:
; |>>> if(i>0)
	ld	a,(iy-5)
	or	a
	jp	m,L00079
	jp	z,L00079
; |>>> DoError(i);
	ld	l,(iy-5)		; i
	push	hl
	call	_DoError
	pop	af
L00079:
; |>>> d=1;
	ld	(iy-6),1		; d
E00076:
; |>>> while(!Exit);
J00073_1:
	ld	a,(iy-1)		; Exit
	or	a
	jp	nz,J00073_
	jp	J00073
J00073_:
	ld	sp,iy
	pop	iy
	ret
_main	endp
; --------------------------------}

; |--- long myAtoi() {

public	_myAtoi
_myAtoi	proc
	push	iy
	ld	iy,0
	add	iy,sp
	push	af
	push	af
	push	af
; |--- long i;
; i = -4
; |--- char ch;
; ch = -5
; |--- char m=0;
; m = -6
	ld	(iy-6),0		; m
; --------------------------------|
; |>>> i=0l;
	ld	(iy-4),0
	ld	(iy-3),0
	ld	(iy-2),0
	ld	(iy-1),0		; i
; |>>> ch=*TextP;
	ld	hl,(_TextP)		; TextP
	ld	l,(hl)
	ld	(iy-5),l		; ch
; |>>> while(ch >='0' && ch <='9' |
J00080_:
	ld	a,(iy-5)
	cp	48
	jp	m,L00081
	ld	a,(iy-5)
	cp	57
	jp	m,L00082
	jp	z,L00082
L00081:
	ld	a,(iy-5)
	cp	46
	jp	nz,J00080
L00082:
; |>>> if(ch=='.')
	ld	a,(iy-5)
	cp	46
	jp	nz,L00083
; |>>> m=1;
	ld	(iy-6),1		; m
L00083:
; |>>> if(!m) {
	ld	a,(iy-6)		; m
	or	a
	jp	nz,L00084
; |>>> i*=10l;
	ld	l,(iy-4)
	ld	h,(iy-3)
	ld	e,(iy-2)
	ld	d,(iy-1)		; i
	push	de
	push	hl
	ld	hl,10
	ld	de,0
	push	de
	push	hl
	call	__lmul
	pop	af
	pop	af
	pop	af
	pop	af
	ld	(iy-4),l
	ld	(iy-3),h
	ld	(iy-2),e
	ld	(iy-1),d		; i
; |>>> i+=(unsigned long)(ch-'0');|
	ld	l,(iy-5)		; ch
	ld	a,l
	sub	48
	ld	l,a
	ld	h,0
	ld	e,h
	ld	d,h
	ld	a,(iy-4)
	add	a,l
	ld	(iy-4),a
	ld	a,(iy-3)
	adc	a,h
	ld	(iy-3),a
	ld	a,(iy-2)
	adc	a,e
	ld	(iy-2),a
	ld	a,(iy-1)
	adc	a,d
	ld	(iy-1),a
L00084:
; |>>> TextP++;
	ld	hl,(_TextP)
	inc	hl
	ld	(_TextP),hl
; |>>> ch=*TextP;
	ld	hl,(_TextP)		; TextP
	ld	l,(hl)
	ld	(iy-5),l		; ch
	jp 	J00080_
J00080:
; |>>> return i;
	ld	l,(iy-4)
	ld	h,(iy-3)
	ld	e,(iy-2)
	ld	d,(iy-1)		; i
	jp	R00085
R00085:
	ld	sp,iy
	pop	iy
	ret
_myAtoi	endp
; --------------------------------}

; |--- int myXtoi() {

public	_myXtoi
_myXtoi	proc
	push	iy
	ld	iy,0
	add	iy,sp
	push	af
	push	af
; |--- int i;
; i = -2
; |--- char ch;
; ch = -3
; --------------------------------|
; |>>> i=0;
	ld	(iy-2),0
	ld	(iy-1),0		; i
; |>>> for(;;) {
J00086_:
; |>>> ch=*TextP;
	ld	hl,(_TextP)		; TextP
	ld	l,(hl)
	ld	(iy-3),l		; ch
; |>>> if(!(_ctype[ch] & 0x80)) 
	ld	hl,__ctype		; addr. _ctype
	ld	e,(iy-3)
	ld	d,0		; ch
	add	hl,de
	ld	l,(hl)
	ld	a,l
	and	128
	ld	l,a
	ld	a,l
	or	a
	ld	l,0
	ld	h,l
	jr	nz,$+3
	inc	l
	ld	a,l
	or	h
	jp	z,L00087
; |>>> break;
	jp	J00086
L00087:
; |>>> ch-='0';
	ld	a,(iy-3)
	sub	48
	ld	(iy-3),a
; |>>> if(ch>=10) {			            |
	ld	a,(iy-3)
	cp	10
	jp	m,L00088
; |>>> if(ch>='\x30')
	ld	a,(iy-3)
	cp	48
	jp	m,L00089
; |>>> ch -= '\x20';
	ld	a,(iy-3)
	sub	32
	ld	(iy-3),a
L00089:
; |>>> ch-=7;
	ld	a,(iy-3)
	sub	7
	ld	(iy-3),a
L00088:
; |>>> i=(i << 4)+(unsigned int)ch|
	ld	l,(iy-2)
	ld	h,(iy-1)		; i
	sla	l
	rl	h
	sla	l
	rl	h
	sla	l
	rl	h
	sla	l
	rl	h
	ld	e,(iy-3)
	ld	d,0		; ch
	add	hl,de
	ld	(iy-2),l
	ld	(iy-1),h		; i
; |>>> TextP++;
	ld	hl,(_TextP)
	inc	hl
	ld	(_TextP),hl
	jp 	J00086_
J00086:
; |>>> return i;
	ld	l,(iy-2)
	ld	h,(iy-1)		; i
	jp	R00090
R00090:
	ld	sp,iy
	pop	iy
	ret
_myXtoi	endp
; --------------------------------}

; |--- int Tokenize() {

public	_Tokenize
_Tokenize	proc
	push	iy
	ld	iy,-12
	add	iy,sp
	ld	sp,iy
	ld	iy,12
	add	iy,sp
	push	ix
; |--- register char *p;
; register ix = p
; |--- char *p1,*p2;
; p1 = -2
; p2 = -4
; |--- int i,j,t;
; i = -6
; j = -8
; t = -10
; |--- char *k;
; k = -12
; --------------------------------|
; |>>> t=0;
	ld	(iy-10),0
	ld	(iy-9),0		; t
; |>>> p=TextP;
	ld	ix,(_TextP)		; p
; |>>> while(*p) {
J00091_:
	ld	a,(ix+0)
	or	a
	jp	z,J00091
; |>>> if(*p>='0' && *p<='9') {
	ld	l,(ix+0)
	ld	a,l
	cp	48
	jp	m,L00092
	ld	l,(ix+0)
	ld	a,l
	cp	57
	jr	z,$+5
	jp	p,L00092
; |>>> p++;
	inc	ix
; |>>> else if(*p == '\"') {
	jp	E00092
L00092:
; |>>> if(*p == '\"') {
	ld	l,(ix+0)
	ld	a,l
	cp	34
	jp	nz,L00093
; |>>> p++;
	inc	ix
; |>>> while(*p && *p!='\"') {
J00094_:
	ld	a,(ix+0)
	or	a
	jp	z,J00094
	ld	l,(ix+0)
	ld	a,l
	cp	34
	jp	z,J00094
; |>>> p++;
	inc	ix
; |>>> t++;
	inc	(iy-10)
	jr	nz,$+5
	inc	(iy-9)
	jp 	J00094_
J00094:
; |>>> else if((_ctype[*p] & (0x1 }
	jp	E00093
L00093:
; |>>> if((_ctype[*p] & (0x1 | 0x2|
	ld	hl,__ctype		; addr. _ctype
	ld	e,(ix+0)
	ld	d,0
	add	hl,de
	ld	l,(hl)
	ld	a,l
	and	3
	ld	l,a
	ld	a,l
	or	a
	jp	z,L00095
; |>>> p1=p;
	push	ix
	pop	hl		; p
	ld	(iy-2),l
	ld	(iy-1),h		; p1
; |>>> i=0;
	ld	(iy-6),0
	ld	(iy-5),0		; i
; |>>> while(k=KeyWords[i]) {
J00096_:
	ld	hl,_KeyWords		; addr. KeyWords
	ld	e,(iy-6)
	ld	d,(iy-5)		; i
	sla	e
	rl	d
	add	hl,de
	ld	a,(hl)
	inc	hl
	ld	h,(hl)
	ld	l,a
	ld	(iy-12),l
	ld	(iy-11),h		; k
	ld	a,l
	or	h
	jp	z,J00096
; |>>> j=strlen(k);
	ld	l,(iy-12)
	ld	h,(iy-11)		; k
	push	hl
	call	_strlen
	pop	af
	ld	(iy-8),l
	ld	(iy-7),h		; j
; |>>> if(!strnicmp(k,p1,j)) {
	ld	l,(iy-8)
	ld	h,(iy-7)		; j
	push	hl
	ld	l,(iy-2)
	ld	h,(iy-1)		; p1
	push	hl
	ld	l,(iy-12)
	ld	h,(iy-11)		; k
	push	hl
	call	_strnicmp
	pop	af
	pop	af
	pop	af
	ld	e,l
	ld	a,l
	or	a
	jp	nz,L00097
; |>>> *p1++=i | 0x80;
	ld	l,(iy-2)
	ld	h,(iy-1)
	inc	(iy-2)
	jr	nz,$+5
	inc	(iy-1)
	ld	e,(iy-6)
	ld	d,(iy-5)		; i
	set	7,e
	ld	(hl),e
; |>>> strcpy(p1,p+j);
	push	ix
	pop	hl		; p
	ld	a,l
	add	a,(iy-8)
	ld	l,a
	ld	a,h
	adc	a,(iy-7)
	ld	h,a
	push	hl
	ld	l,(iy-2)
	ld	h,(iy-1)		; p1
	push	hl
	call	_strcpy
	pop	af
	pop	af
; |>>> p=p1;
	ld	l,(iy-2)
	ld	h,(iy-1)		; p1
	push	hl
	pop	ix		; p
; |>>> break;
	jp	J00096
L00097:
; |>>> i++;
	inc	(iy-6)
	jr	nz,$+5
	inc	(iy-5)
	jp 	J00096_
J00096:
; |>>> if(!k) {
	ld	a,(iy-12)
	or	(iy-11)		; k
	jp	nz,L00098
; |>>> p1=p;
	push	ix
	pop	hl		; p
	ld	(iy-2),l
	ld	(iy-1),h		; p1
; |>>> i=0;
	ld	(iy-6),0
	ld	(iy-5),0		; i
; |>>> while(k=Funct[i]) {
J00099_:
	ld	hl,_Funct		; addr. Funct
	ld	e,(iy-6)
	ld	d,(iy-5)		; i
	sla	e
	rl	d
	add	hl,de
	ld	a,(hl)
	inc	hl
	ld	h,(hl)
	ld	l,a
	ld	(iy-12),l
	ld	(iy-11),h		; k
	ld	a,l
	or	h
	jp	z,J00099
; |>>> j=strlen(k);
	ld	l,(iy-12)
	ld	h,(iy-11)		; k
	push	hl
	call	_strlen
	pop	af
	ld	(iy-8),l
	ld	(iy-7),h		; j
; |>>> if(!strnicmp(k,p1,j)) {
	ld	l,(iy-8)
	ld	h,(iy-7)		; j
	push	hl
	ld	l,(iy-2)
	ld	h,(iy-1)		; p1
	push	hl
	ld	l,(iy-12)
	ld	h,(iy-11)		; k
	push	hl
	call	_strnicmp
	pop	af
	pop	af
	pop	af
	ld	e,l
	ld	a,l
	or	a
	jp	nz,L00100
; |>>> *p1++=i | 0xc0;
	ld	l,(iy-2)
	ld	h,(iy-1)
	inc	(iy-2)
	jr	nz,$+5
	inc	(iy-1)
	ld	e,(iy-6)
	ld	d,(iy-5)		; i
	ld	a,e
	or	192
	ld	e,a
	ld	(hl),e
; |>>> strcpy(p1,p+j);
	push	ix
	pop	hl		; p
	ld	a,l
	add	a,(iy-8)
	ld	l,a
	ld	a,h
	adc	a,(iy-7)
	ld	h,a
	push	hl
	ld	l,(iy-2)
	ld	h,(iy-1)		; p1
	push	hl
	call	_strcpy
	pop	af
	pop	af
; |>>> p=p1;
	ld	l,(iy-2)
	ld	h,(iy-1)		; p1
	push	hl
	pop	ix		; p
; |>>> break;
	jp	J00099
L00100:
; |>>> i++;
	inc	(iy-6)
	jr	nz,$+5
	inc	(iy-5)
	jp 	J00099_
J00099:
; |>>> if(!k) {
	ld	a,(iy-12)
	or	(iy-11)		; k
	jp	nz,L00101
; |>>> p++;
	inc	ix
L00101:
L00098:
; |>>> else if(*p=='?') {         }
	jp	E00095
L00095:
; |>>> if(*p=='?') {              |
	ld	l,(ix+0)
	ld	a,l
	cp	63
	jp	nz,L00102
; |>>> *p++=0x86;
	push	ix
	pop	hl
	inc	ix
	ld	(hl),134
; |>>> else if(*p=='\'') {        }
	jp	E00102
L00102:
; |>>> if(*p=='\'') {             |
	ld	l,(ix+0)
	ld	a,l
	cp	39
	jp	nz,L00103
; |>>> *p++=0x87;
	push	ix
	pop	hl
	inc	ix
	ld	(hl),135
; |>>> else {
	jp	E00103
L00103:
; |>>> p++;
	inc	ix
E00103:
E00102:
E00095:
E00093:
E00092:
; |>>> t++;	
	inc	(iy-10)
	jr	nz,$+5
	inc	(iy-9)
	jp 	J00091_
J00091:
; |>>> return t;
	ld	l,(iy-10)
	ld	h,(iy-9)		; t
	jp	R00104
R00104:
	pop	ix
	ld	sp,iy
	pop	iy
	ret
_Tokenize	endp
; --------------------------------}

; |--- int GetLine() {

public	_GetLine
_GetLine	proc
	push	iy
	ld	iy,0
	add	iy,sp
	push	af
	push	ix
; |--- char ch;
; ch = -1
; |--- char i;
; i = -2
; |--- register char *p;
; register ix = p
; --------------------------------|
; |>>> cursOn();
	call	_cursOn
; |>>> p=TextP;
	ld	ix,(_TextP)		; p
; |>>> *p=0;
	ld	(ix+0),0
; |>>> i=0;
	ld	(iy-2),0		; i
; |>>> ch=0;
	ld	(iy-1),0		; ch
; |>>> do {
J00105:
; |>>> if(kbhit()) {
	call	_kbhit
	ld	a,l
	or	a
	jp	z,L00106
; |>>> ch=getch();
	call	_getch
	ld	(iy-1),l		; ch
; |>>> if((_ctype[ch] & (0x40 | 0x|
	ld	hl,__ctype		; addr. _ctype
	ld	e,(iy-1)
	ld	d,0		; ch
	add	hl,de
	ld	l,(hl)
	ld	a,l
	and	87
	ld	l,a
	ld	a,l
	or	a
	jp	z,L00107
; |>>> if(i < 80) {
	ld	a,(iy-2)
	cp	80
	jp	p,L00108
; |>>> putch(ch);
	ld	l,(iy-1)		; ch
	push	hl
	call	_putch
	pop	af
; |>>> *p++=ch;
	push	ix
	pop	hl
	inc	ix
	ld	e,(iy-1)		; ch
	ld	(hl),e
; |>>> *p=0;
	ld	(ix+0),0
; |>>> i++;
	inc	(iy-2)
; |>>> else {
	jp	E00108
L00108:
; |>>> putch(7);
	ld	l,7
	push	hl
	call	_putch
	pop	af
E00108:
; |>>> else {
	jp	E00107
L00107:
Get2_GetLine:
; |>>> if(ch==8) {
	ld	a,(iy-1)
	cp	8
	jp	nz,L00109
; |>>> if(i>0) {
	ld	a,(iy-2)
	or	a
	jp	m,L00110
	jp	z,L00110
; |>>> putch(8);
	ld	l,8
	push	hl
	call	_putch
	pop	af
; |>>> i--;
	dec	(iy-2)
; |>>> p--;
	dec	ix
; |>>> *p=0;
	ld	(ix+0),0
; |>>> else
	jp	E00110
L00110:
; |>>> putch(7);
	ld	l,7
	push	hl
	call	_putch
	pop	af
E00110:
L00109:
E00107:
L00106:
; |>>> _asm {
	 ld e, 41
	 rst 8
; |>>> while(ch != 10);
J00105_1:
	ld	a,(iy-1)
	cp	10
	jp	z,J00105_
	jp	J00105
J00105_:
; |>>> putch(10);
	ld	l,10
	push	hl
	call	_putch
	pop	af
; |>>> *p=0;
	ld	(ix+0),0
; |>>> cursOff();
	call	_cursOff
	pop	ix
	pop	af
	pop	iy
	ret
_GetLine	endp
; --------------------------------}

; |--- int StoreLine(int t) {

public	_StoreLine
_StoreLine	proc
	push	iy
	ld	iy,-8
	add	iy,sp
	ld	sp,iy
	ld	iy,8
	add	iy,sp
	push	ix
; t = 4
; |--- register char **p;
; register ix = p
; |--- char *p1;
; p1 = -2
; |--- int i,n;
; i = -4
; n = -6
; |--- char m;
; m = -7
; --------------------------------|
; |>>> p=TextP;
	ld	ix,(_TextP)		; p
; |>>> n=myAtoi();
	call	_myAtoi
	ld	(iy-6),l
	ld	(iy-5),h		; n
; |>>> m=0;
	ld	(iy-7),0		; m
; |>>> while(*TextP) {            |
J00111_:
	ld	hl,(_TextP)		; TextP
	ld	a,(hl)
	or	a
	jp	z,J00111
; |>>> if(*TextP != ' ') {
	ld	hl,(_TextP)		; TextP
	ld	l,(hl)
	ld	a,l
	cp	32
	jp	z,L00112
; |>>> m=1;
	ld	(iy-7),1		; m
; |>>> break;
	jp	J00111
L00112:
; |>>> TextP++;
	ld	hl,(_TextP)
	inc	hl
	ld	(_TextP),hl
	jp 	J00111_
J00111:
; |>>> t=t-(TextP-p);
	ld	de,(_TextP)		; TextP
	push	ix
	pop	bc		; p
	ld	a,e
	sub	c
	ld	e,a
	ld	a,d
	sbc	a,b
	ld	d,a
	ld	l,(iy+4)
	ld	h,(iy+5)		; t
	or	a
	sbc	hl,de
	ld	(iy+4),l
	ld	(iy+5),h		; t
; |>>> if(m) {
	ld	a,(iy-7)		; m
	or	a
	jp	z,L00113
; |>>> if(p=CercaLine(n,0)) {
	xor	a
	ld	l,a
	push	hl
	ld	l,(iy-6)
	ld	h,(iy-5)		; n
	push	hl
	call	_CercaLine
	pop	af
	pop	af
	push	hl
	pop	ix		; p
	ld	a,l
	or	h
	jp	z,L00114
; |>>> p1=p+2;
	push	ix
	pop	hl		; p
	inc	hl
	inc	hl
	inc	hl
	inc	hl
	ld	(iy-2),l
	ld	(iy-1),h		; p1
; |>>> i=4;
	ld	(iy-4),4
	ld	(iy-3),0		; i
; |>>> while(*p1++)
J00115_:
	ld	l,(iy-2)
	ld	h,(iy-1)
	inc	(iy-2)
	jr	nz,$+5
	inc	(iy-1)
	ld	a,(hl)
	or	a
	jp	z,J00115
; |>>> i++;
	inc	(iy-4)
	jr	nz,$+5
	inc	(iy-3)
	jp 	J00115_
J00115:
; |>>> memmove(p,p1,VarEnd-p1);
	ld	hl,(_VarEnd)		; VarEnd
	ld	a,l
	sub	(iy-2)
	ld	l,a
	ld	a,h
	sbc	a,(iy-1)
	ld	h,a
	push	hl
	ld	l,(iy-2)
	ld	h,(iy-1)		; p1
	push	hl
	push	ix
	call	_memmove
	pop	af
	pop	af
	pop	af
; |>>> VarBase-=i;
	ld	hl,(_VarBase)		; VarBase
	ld	a,l
	sub	(iy-4)
	ld	l,a
	ld	a,h
	sbc	a,(iy-3)
	ld	h,a
	ld	(_VarBase),hl		; VarBase
; |>>> else {
	jp	E00114
L00114:
; |>>> if(!(p=CercaLine(n,1)))
	ld	l,1
	push	hl
	ld	l,(iy-6)
	ld	h,(iy-5)		; n
	push	hl
	call	_CercaLine
	pop	af
	pop	af
	push	hl
	pop	ix		; p
	ld	a,l
	or	a
	ld	l,0
	ld	h,l
	jr	nz,$+3
	inc	l
	ld	a,l
	or	h
	jp	z,L00116
; |>>> p=VarBase-2;
	ld	hl,(_VarBase)		; VarBase
	dec	hl
	dec	hl
	push	hl
	pop	ix		; p
L00116:
E00114:
; |>>> i=t+5;
	ld	l,(iy+4)
	ld	h,(iy+5)		; t
	ld	a,l
	add	a,5
	ld	l,a
	ld	a,h
	adc	a,0
	ld	h,a
	ld	(iy-4),l
	ld	(iy-3),h		; i
; |>>> memmove(((char *)p)+i,p,Var`
	ld	hl,(_VarEnd)		; VarEnd
	push	ix
	pop	de		; p
	or	a
	sbc	hl,de
	push	hl
	push	ix
	push	ix
	pop	hl		; p
	ld	a,l
	add	a,(iy-4)
	ld	l,a
	ld	a,h
	adc	a,(iy-3)
	ld	h,a
	push	hl
	call	_memmove
	pop	af
	pop	af
	pop	af
; |>>> VarBase+=i;
	ld	hl,(_VarBase)		; VarBase
	ld	a,l
	add	a,(iy-4)
	ld	l,a
	ld	a,h
	adc	a,(iy-3)
	ld	h,a
	ld	(_VarBase),hl		; VarBase
; |>>> p[1]=n;
	ld	e,(iy-6)
	ld	d,(iy-5)		; n
	ld	(ix+2),e
	ld	(ix+3),d
; |>>> p1=p+2;
	push	ix
	pop	hl		; p
	inc	hl
	inc	hl
	inc	hl
	inc	hl
	ld	(iy-2),l
	ld	(iy-1),h		; p1
; |>>> strcpy(p1,TextP);
	ld	hl,(_TextP)		; TextP
	push	hl
	ld	l,(iy-2)
	ld	h,(iy-1)		; p1
	push	hl
	call	_strcpy
	pop	af
	pop	af
; |>>> *(p1+t+1)=0;
	ld	l,(iy-2)
	ld	h,(iy-1)		; p1
	ld	a,l
	add	a,(iy+4)
	ld	l,a
	ld	a,h
	adc	a,(iy+5)
	ld	h,a
	inc	hl
	ld	(hl),0
; |>>> *p=((char *)p)+i;
	push	ix
	pop	de		; p
	ld	a,e
	add	a,(iy-4)
	ld	e,a
	ld	a,d
	adc	a,(iy-3)
	ld	d,a
	ld	(ix+0),e
	ld	(ix+1),d
; |>>> else {
	jp	E00113
L00113:
; |>>> if(p=CercaLine(n,0)) {
	xor	a
	ld	l,a
	push	hl
	ld	l,(iy-6)
	ld	h,(iy-5)		; n
	push	hl
	call	_CercaLine
	pop	af
	pop	af
	push	hl
	pop	ix		; p
	ld	a,l
	or	h
	jp	z,L00117
; |>>> p1=p+2;
	push	ix
	pop	hl		; p
	inc	hl
	inc	hl
	inc	hl
	inc	hl
	ld	(iy-2),l
	ld	(iy-1),h		; p1
; |>>> i=4;
	ld	(iy-4),4
	ld	(iy-3),0		; i
; |>>> while(*p1++)
J00118_:
	ld	l,(iy-2)
	ld	h,(iy-1)
	inc	(iy-2)
	jr	nz,$+5
	inc	(iy-1)
	ld	a,(hl)
	or	a
	jp	z,J00118
; |>>> i++;
	inc	(iy-4)
	jr	nz,$+5
	inc	(iy-3)
	jp 	J00118_
J00118:
; |>>> memmove(p,p1,VarEnd-p1);
	ld	hl,(_VarEnd)		; VarEnd
	ld	a,l
	sub	(iy-2)
	ld	l,a
	ld	a,h
	sbc	a,(iy-1)
	ld	h,a
	push	hl
	ld	l,(iy-2)
	ld	h,(iy-1)		; p1
	push	hl
	push	ix
	call	_memmove
	pop	af
	pop	af
	pop	af
; |>>> VarBase-=i;
	ld	hl,(_VarBase)		; VarBase
	ld	a,l
	sub	(iy-4)
	ld	l,a
	ld	a,h
	sbc	a,(iy-3)
	ld	h,a
	ld	(_VarBase),hl		; VarBase
L00117:
E00113:
; |>>> RelinkBasic();
	call	_RelinkBasic
	pop	ix
	ld	sp,iy
	pop	iy
	ret
_StoreLine	endp
; --------------------------------}

; |--- int RelinkBasic() {

public	_RelinkBasic
_RelinkBasic	proc
	push	iy
	ld	iy,0
	add	iy,sp
	push	af
	push	ix
; |--- register char **p,*p1;
; register ix = p
; p1 = -2
; --------------------------------`
; |>>> p=PrgBase;
	ld	ix,(_PrgBase)		; p
; |>>> while(*p) {                `
J00119_:
	ld	a,(ix+0)
	or	(ix+1)
	jp	z,J00119
; |>>> p1=p+2;
	push	ix
	pop	hl		; p
	inc	hl
	inc	hl
	inc	hl
	inc	hl
	ld	(iy-2),l
	ld	(iy-1),h		; p1
; |>>> while(*p1++);
J00120_:
	ld	l,(iy-2)
	ld	h,(iy-1)
	inc	(iy-2)
	jr	nz,$+5
	inc	(iy-1)
	ld	a,(hl)
	or	a
	jp	z,J00120
; |>>> ;
	jp 	J00120_
J00120:
; |>>> *p=p1;
	ld	e,(iy-2)
	ld	d,(iy-1)		; p1
	ld	(ix+0),e
	ld	(ix+1),d
; |>>> p=p1;
	ld	l,(iy-2)
	ld	h,(iy-1)		; p1
	push	hl
	pop	ix		; p
	jp 	J00119_
J00119:
; |>>> VarBase=p+1;
	push	ix
	pop	hl		; p
	inc	hl
	inc	hl
	ld	(_VarBase),hl		; VarBase
; |>>> VarEnd=VarBase;
	ld	hl,(_VarBase)		; VarBase
	ld	(_VarEnd),hl		; VarEnd
; |>>> StrBase=MemTop;
	ld	hl,(_MemTop)		; MemTop
	ld	(_StrBase),hl		; StrBase
	pop	ix
	pop	af
	pop	iy
	ret
_RelinkBasic	endp
; --------------------------------}

; |--- char *HandleVar(char mode, `

public	_HandleVar
_HandleVar	proc
	push	iy
	ld	iy,-12
	add	iy,sp
	ld	sp,iy
	ld	iy,12
	add	iy,sp
; mode = 4
; flags = 6
; |--- char nome[4];
; nome = -4
; |--- unsigned char i;
; i = -5
; |--- char ch,j;
; ch = -6
; j = -7
; |--- char *p;
; p = -10
; |--- char *VarPtr;
; VarPtr = -12
; --------------------------------`
; |>>> i=0;  
	ld	(iy-5),0		; i
; |>>> *flags=0;
	ld	l,(iy+6)
	ld	h,(iy+7)		; flags
	ld	(hl),0
; |>>> *(long *)&nome=0l;
	push	iy
	pop	hl
	dec	hl
	dec	hl
	dec	hl
	dec	hl		; addr. nome
	ld	(hl),0
	inc	hl
	ld	(hl),0
	inc	hl
	ld	(hl),0
	inc	hl
	ld	(hl),0
; |>>> SkipSpaces();
	call	_SkipSpaces
; |>>> ch=*TextP;
	ld	hl,(_TextP)		; TextP
	ld	l,(hl)
	ld	(iy-6),l		; ch
; |>>> if((_ctype[ch] & (0x1 | 0x2|
	ld	hl,__ctype		; addr. _ctype
	ld	e,(iy-6)
	ld	d,0		; ch
	add	hl,de
	ld	l,(hl)
	ld	a,l
	and	3
	ld	l,a
	ld	a,l
	or	a
	jp	z,L00121
rifo_HandleVar:
; |>>> nome[i]=*TextP++ & 0xdf;
	push	iy
	pop	hl
	dec	hl
	dec	hl
	dec	hl
	dec	hl		; addr. nome
	ld	e,(iy-5)
	ld	d,0		; i
	add	hl,de
	ld	bc,(_TextP)
	ld	e,c
	ld	d,b
	inc	bc
	ld	(_TextP),bc
	ld	a,(de)
	ld	e,a
	ld	a,e
	and	223
	ld	e,a
	ld	(hl),e
rifo2_HandleVar:
; |>>> switch(*TextP) {
	ld	hl,(_TextP)		; TextP
	ld	l,(hl)
	ld	a,l
	cp	37
	jp	z,J00122_25
	cp	36
	jp	z,J00122_24
	cp	40
	jp	z,J00122_28
	jp	J00122_
; |>>> case '%':
J00122_25:
; |>>> *flags |= 1;
	ld	l,(iy+6)
	ld	h,(iy+7)		; flags
	set	0,(hl)
; |>>> nome[0] |= 0x80;
	push	iy
	pop	hl
	dec	hl
	dec	hl
	dec	hl
	dec	hl		; addr. nome
	set	7,(hl)
; |>>> nome[1] |= 0x80;
	push	iy
	pop	hl
	dec	hl
	dec	hl
	dec	hl		; addr. nome
	set	7,(hl)
; |>>> TextP++;
	ld	hl,(_TextP)
	inc	hl
	ld	(_TextP),hl
; |>>> break;
	jp	J00122
; |>>> case '$':
J00122_24:
; |>>> *flags |= 2;
	ld	l,(iy+6)
	ld	h,(iy+7)		; flags
	set	1,(hl)
; |>>> nome[1] |= 0x80;
	push	iy
	pop	hl
	dec	hl
	dec	hl
	dec	hl		; addr. nome
	set	7,(hl)
; |>>> TextP++;
	ld	hl,(_TextP)
	inc	hl
	ld	(_TextP),hl
; |>>> break;
	jp	J00122
; |>>> case '(':
J00122_28:
; |>>> goto HndVar2;
	jp	HndVar2_HandleVar
; |>>> break;
	jp	J00122
; |>>> default:
J00122_:
; |>>> ch=*TextP;
	ld	hl,(_TextP)		; TextP
	ld	l,(hl)
	ld	(iy-6),l		; ch
; |>>> j=(_ctype[ch] & (0x1 | 0x2 `
	ld	hl,__ctype		; addr. _ctype
	ld	e,(iy-6)
	ld	d,0		; ch
	add	hl,de
	ld	l,(hl)
	ld	a,l
	and	7
	ld	l,a
	ld	(iy-7),l		; j
; |>>> if(i<1) {
	ld	a,(iy-5)
	cp	1
	jp	nc,L00123
; |>>> if(ch && j) {
	ld	a,(iy-6)		; ch
	or	a
	jp	z,L00124
	ld	a,(iy-7)		; j
	or	a
	jp	z,L00124
; |>>> i++;
	inc	(iy-5)
; |>>> goto rifo;
	jp	rifo_HandleVar
L00124:
; |>>> else {
	jp	E00123
L00123:
; |>>> if(ch && j) {
	ld	a,(iy-6)		; ch
	or	a
	jp	z,L00125
	ld	a,(iy-7)		; j
	or	a
	jp	z,L00125
; |>>> do {
J00126:
; |>>> ch=*(++TextP);
	ld	hl,(_TextP)
	inc	hl
	ld	(_TextP),hl
	ld	l,(hl)
	ld	(iy-6),l		; ch
; |>>> while(ch && (_ctype[ch] & (|
J00126_1:
	ld	a,(iy-6)		; ch
	or	a
	jp	z,J00126_
	ld	hl,__ctype		; addr. _ctype
	ld	e,(iy-6)
	ld	d,0		; ch
	add	hl,de
	ld	l,(hl)
	ld	a,l
	and	7
	ld	l,a
	ld	a,l
	or	a
	jp	z,J00126_
	jp	J00126
J00126_:
; |>>> goto rifo2;
	jp	rifo2_HandleVar
L00125:
E00123:
; |>>> break;
	jp	J00122
J00122:
; |>>> VarPtr=0;
	ld	(iy-12),0
	ld	(iy-11),0		; VarPtr
; |>>> p=VarBase;
	ld	hl,(_VarBase)		; VarBase
	ld	(iy-10),l
	ld	(iy-9),h		; p
; |>>> while(p<VarEnd) {
J00127_:
	ld	l,(iy-10)
	ld	h,(iy-9)		; p
	ld	de,(_VarEnd)		; VarEnd
	ld	a,l
	sub	e
	ld	a,h
	sbc	a,d
	jp	p,J00127
; |>>> if(*(int *)&nome==*(int *)p|
	push	iy
	pop	hl
	dec	hl
	dec	hl
	dec	hl
	dec	hl		; addr. nome
	ld	e,(iy-10)
	ld	d,(iy-9)		; p
	ld	a,(hl)
	inc	hl
	ld	h,(hl)
	ld	l,a
	ld	a,(de)
	inc	de
	push	af
	ld	a,(de)
	ld	d,a
	pop	af
	ld	e,a
	ld	a,l
	cp	e
	jr	nz,J00129
	ld	a,h
	cp	d
J00129:
	jp	nz,L00128
; |>>> VarPtr=p+2;
	ld	l,(iy-10)
	ld	h,(iy-9)		; p
	inc	hl
	inc	hl
	ld	(iy-12),l
	ld	(iy-11),h		; VarPtr
; |>>> break;
	jp	J00127
L00128:
; |>>> p+=6;
	ld	a,(iy-10)
	add	a,6
	ld	(iy-10),a
	ld	a,(iy-9)
	adc	a,0
	ld	(iy-9),a
	jp 	J00127_
J00127:
; |>>> if(!VarPtr) {
	ld	a,(iy-12)
	or	(iy-11)		; VarPtr
	jp	nz,L00130
; |>>> p=VarEnd;
	ld	hl,(_VarEnd)		; VarEnd
	ld	(iy-10),l
	ld	(iy-9),h		; p
; |>>> *p++=nome[0];
	ld	l,(iy-10)
	ld	h,(iy-9)
	inc	(iy-10)
	jr	nz,$+5
	inc	(iy-9)
	push	iy
	pop	de
	dec	de
	dec	de
	dec	de
	dec	de		; addr. nome
	ld	a,(de)
	ld	e,a
	ld	(hl),e
; |>>> *p++=nome[1];
	ld	l,(iy-10)
	ld	h,(iy-9)
	inc	(iy-10)
	jr	nz,$+5
	inc	(iy-9)
	push	iy
	pop	de
	dec	de
	dec	de
	dec	de		; addr. nome
	ld	a,(de)
	ld	e,a
	ld	(hl),e
; |>>> *(long *)p=0l;
	ld	l,(iy-10)
	ld	h,(iy-9)		; p
	ld	(hl),0
	inc	hl
	ld	(hl),0
	inc	hl
	ld	(hl),0
	inc	hl
	ld	(hl),0
; |>>> VarPtr=VarEnd+2;
	ld	hl,(_VarEnd)		; VarEnd
	inc	hl
	inc	hl
	ld	(iy-12),l
	ld	(iy-11),h		; VarPtr
; |>>> VarEnd+=6;
	ld	hl,(_VarEnd)		; VarEnd
	ld	a,l
	add	a,6
	ld	l,a
	ld	a,h
	adc	a,0
	ld	h,a
	ld	(_VarEnd),hl		; VarEnd
L00130:
; |>>> return VarPtr;
	ld	l,(iy-12)
	ld	h,(iy-11)		; VarPtr
	jp	R00131
; |>>> else {
	jp	E00121
L00121:
HndVar2_HandleVar:
; |>>> fError=1;
	ld	l,1
	ld	a,l
	ld	(_fError),a		; fError
; |>>> return 0;
	ld	hl,0
	jp	R00131
E00121:
R00131:
	ld	sp,iy
	pop	iy
	ret
_HandleVar	endp
; --------------------------------}

; |--- char ExecStmt(char n) {

public	_ExecStmt
_ExecStmt	proc
; temp = -32
	push	iy
	ld	iy,-32
	add	iy,sp
	ld	sp,iy
	ld	iy,32
	add	iy,sp
	push	ix
; n = 4
; |--- char RetVal=0;
; RetVal = -1
	ld	(iy-1),0		; RetVal
; |--- char *p,*p1;
; p = -4
; p1 = -6
; |--- char Fl,Fl1;
; Fl = -7
; Fl1 = -8
; |--- char ch;
; ch = -9
; |--- register int i,i1;
; register ix = i
; i1 = -12
; |--- long l;                    `
; l = -16
; |--- char *OldText=0,*OldVar;   `
; OldText = -18
	ld	(iy-18),0
	ld	(iy-17),0		; OldText
; OldVar = -20
; |--- long ToVal,StVal;          `
; ToVal = -24
; StVal = -28
; |>>> switch(n) {
	ld	l,(iy+4)		; n
	ld	a,l
	ld	hl,J00132_T-1
	ld	bc,27
	cpdr
	ld	a,b
	or	c
	jp	z,J00132_
	ld	hl,J00132_T-2
	add	hl,bc
	add	hl,bc
	ld	a,(hl)
	inc	hl
	ld	h,(hl)
	ld	l,a
	jp	(hl)
J00132_N:
db		128
db		129
db		131
db		130
db		132
db		133
db		134
db		135
db		136
db		139
db		141
db		140
db		142
db		143
db		146
db		147
db		148
db		149
db		150
db		151
db		152
db		153
db		154
db		155
db		58
db		32
J00132_T:
dw	J00132_80
dw	J00132_81
dw	J00132_83
dw	J00132_82
dw	J00132_84
dw	J00132_85
dw	J00132_86
dw	J00132_87
dw	J00132_88
dw	J00132_8b
dw	J00132_8d
dw	J00132_8c
dw	J00132_8e
dw	J00132_8f
dw	J00132_92
dw	J00132_93
dw	J00132_94
dw	J00132_95
dw	J00132_96
dw	J00132_97
dw	J00132_98
dw	J00132_99
dw	J00132_9a
dw	J00132_9b
dw	J00132_3a
dw	J00132_20
; |>>> case '\x80':
J00132_80:
; |>>> RetVal=-1;
	ld	(iy-1),255		; RetVal
; |>>> break;  
	jp	J00132
; |>>> case '\x81':               |
J00132_81:
; |>>> *(int *)PrgBase=0;
	ld	hl,(_PrgBase)		; PrgBase
	ld	(hl),0
	inc	hl
	ld	(hl),0
; |>>> VarBase=PrgBase+2;
	ld	hl,(_PrgBase)		; PrgBase
	inc	hl
	inc	hl
	ld	(_VarBase),hl		; VarBase
; |>>> case '\x83':               |
J00132_83:
doClr_ExecStmt:
; |>>> VarEnd=VarBase;
	ld	hl,(_VarBase)		; VarBase
	ld	(_VarEnd),hl		; VarEnd
; |>>> StrBase=MemTop;
	ld	hl,(_MemTop)		; MemTop
	ld	(_StrBase),hl		; StrBase
; |>>> if(n == '\x83') {
	ld	a,(iy+4)
	cp	131
	jp	nz,L00133
; |>>> if(*(int *)PrgBase) {
	ld	hl,(_PrgBase)		; PrgBase
	ld	a,(hl)
	inc	hl
	or	(hl)
	jp	z,L00134
; |>>> DirectMode=0;
	xor	a
	ld	l,a
	ld	a,l
	ld	(_DirectMode),a		; DirectMode
; |>>> TextP=PrgBase+4;
	ld	hl,(_PrgBase)		; PrgBase
	inc	hl
	inc	hl
	inc	hl
	inc	hl
	ld	(_TextP),hl		; TextP
; |>>> Linea=*(int *)(TextP-2);
	ld	hl,(_TextP)		; TextP
	dec	hl
	dec	hl
	ld	a,(hl)
	inc	hl
	ld	h,(hl)
	ld	l,a
	ld	(_Linea),hl		; Linea
L00134:
L00133:
; |>>> break;  
	jp	J00132
; |>>> case '\x82':               |
J00132_82:
; |>>> i=GetValue(0);
	xor	a
	ld	l,a
	push	hl
	call	_GetValue
	pop	af
	push	hl
	pop	ix		; i
; |>>> if(fError) {
	ld	a,(_fError)		; fError
	or	a
	jp	z,L00135
; |>>> fError=0;
	xor	a
	ld	l,a
	ld	a,l
	ld	(_fError),a		; fError
; |>>> p=PrgBase;
	ld	hl,(_PrgBase)		; PrgBase
	ld	(iy-4),l
	ld	(iy-3),h		; p
; |>>> i=0x7fff;
	ld	ix,32767		; i
; |>>> else {
	jp	E00135
L00135:
; |>>> p=CercaLine(i,0);
	xor	a
	ld	l,a
	push	hl
	push	ix
	call	_CercaLine
	pop	af
	pop	af
	ld	(iy-4),l
	ld	(iy-3),h		; p
E00135:
; |>>> if(p) {
	ld	a,(iy-4)
	or	(iy-3)		; p
	jp	z,L00136
; |>>> while(p1=(*(char **)p)) {
J00137_:
	ld	l,(iy-4)
	ld	h,(iy-3)		; p
	ld	a,(hl)
	inc	hl
	ld	h,(hl)
	ld	l,a
	ld	(iy-6),l
	ld	(iy-5),h		; p1
	ld	a,l
	or	h
	jp	z,J00137
; |>>> i1=*((int *)(p+2));
	ld	l,(iy-4)
	ld	h,(iy-3)		; p
	inc	hl
	inc	hl
	ld	a,(hl)
	inc	hl
	ld	h,(hl)
	ld	l,a
	ld	(iy-12),l
	ld	(iy-11),h		; i1
; |>>> if(i1>i)                  /|
	push	ix
	pop	hl		; i
	ld	a,(iy-12)
	scf
	sbc	a,l
	ld	a,(iy-11)
	sbc	a,h
	jp	m,L00138
; |>>> break;
	jp	J00137
L00138:
; |>>> printf("%u ",i1);
	ld	l,(iy-12)
	ld	h,(iy-11)		; i1
	push	hl
	ld	hl,L00139
	push	hl
	call	_printf
	pop	af
	pop	af
; |>>> p+=4;
	ld	a,(iy-4)
	add	a,4
	ld	(iy-4),a
	ld	a,(iy-3)
	adc	a,0
	ld	(iy-3),a
; |>>> while(*p) {
J00140_:
	ld	l,(iy-4)
	ld	h,(iy-3)		; p
	ld	a,(hl)
	or	a
	jp	z,J00140
; |>>> if(*p < 0) {
	ld	l,(iy-4)
	ld	h,(iy-3)		; p
	ld	l,(hl)
	ld	a,l
	or	a
	jp	p,L00141
; |>>> if(*p < '\xc0')
	ld	l,(iy-4)
	ld	h,(iy-3)		; p
	ld	l,(hl)
	ld	a,l
	cp	192
	jp	p,L00142
; |>>> printf(KeyWords[*p & 0x3f])`
	ld	e,(iy-4)
	ld	d,(iy-3)		; p
	ld	a,(de)
	ld	e,a
	ld	a,e
	and	63
	ld	e,a
	ld	hl,_KeyWords		; addr. KeyWords
	ld	d,0
	sla	e
	rl	d
	add	hl,de
	ld	a,(hl)
	inc	hl
	ld	h,(hl)
	ld	l,a
	push	hl
	call	_printf
	pop	af
	jp	E00142
L00142:
; |>>> else
; |>>> printf(Funct[*p & 0x3f]);
	ld	e,(iy-4)
	ld	d,(iy-3)		; p
	ld	a,(de)
	ld	e,a
	ld	a,e
	and	63
	ld	e,a
	ld	hl,_Funct		; addr. Funct
	ld	d,0
	sla	e
	rl	d
	add	hl,de
	ld	a,(hl)
	inc	hl
	ld	h,(hl)
	ld	l,a
	push	hl
	call	_printf
	pop	af
E00142:
; |>>> else
	jp	E00141
L00141:
; |>>> putch(*p);
	ld	l,(iy-4)
	ld	h,(iy-3)		; p
	ld	l,(hl)
	push	hl
	call	_putch
	pop	af
E00141:
; |>>> p++;
	inc	(iy-4)
	jr	nz,$+5
	inc	(iy-3)
	jp 	J00140_
J00140:
; |>>> p++;
	inc	(iy-4)
	jr	nz,$+5
	inc	(iy-3)
; |>>> if(isBreak())
	call	_isBreak
	ld	a,l
	or	a
	jp	z,L00143
; |>>> RetVal=17;
	ld	(iy-1),17		; RetVal
L00143:
; |>>> putch(10);
	ld	l,10
	push	hl
	call	_putch
	pop	af
	jp 	J00137_
J00137:
L00136:
; |>>> break;  
	jp	J00132
; |>>> case '\x84':               `
J00132_84:
; |>>> DirectMode=1;
	ld	l,1
	ld	a,l
	ld	(_DirectMode),a		; DirectMode
; |>>> TextP=VarBase-3;
	ld	hl,(_VarBase)		; VarBase
	dec	hl
	dec	hl
	dec	hl
	ld	(_TextP),hl		; TextP
; |>>> break;  
	jp	J00132
; |>>> case '\x85':               |
J00132_85:
; |>>> RetVal=17;
	ld	(iy-1),17		; RetVal
; |>>> break;  
	jp	J00132
; |>>> case '\x86':               |
J00132_86:
; |>>> ch=0;
	ld	(iy-9),0		; ch
myPrint_ExecStmt:
; |>>> if(!fError) {
	ld	a,(_fError)		; fError
	or	a
	jp	nz,L00144
; |>>> switch(*TextP) {
	ld	hl,(_TextP)		; TextP
	ld	l,(hl)
	ld	a,l
	cp	59
	jp	z,J00145_3b
	cp	32
	jp	z,J00145_20
	cp	44
	jp	z,J00145_2c
	cp	0
	jp	z,J00145_0
	cp	58
	jp	z,J00145_3a
	jp	J00145_
; |>>> case ';':
J00145_3b:
; |>>> ch=1;
	ld	(iy-9),1		; ch
; |>>> case ' ':
J00145_20:
; |>>> TextP++;
	ld	hl,(_TextP)
	inc	hl
	ld	(_TextP),hl
; |>>> goto myPrint;
	jp	myPrint_ExecStmt
; |>>> break;
	jp	J00145
; |>>> case ',':
J00145_2c:
; |>>> putch('\t');
	ld	l,9
	push	hl
	call	_putch
	pop	af
; |>>> TextP++;
	ld	hl,(_TextP)
	inc	hl
	ld	(_TextP),hl
; |>>> ch=1;
	ld	(iy-9),1		; ch
; |>>> goto myPrint;
	jp	myPrint_ExecStmt
; |>>> break;
	jp	J00145
; |>>> case 0:
J00145_0:
; |>>> case ':':
J00145_3a:
; |>>> if(!ch) {                  |
	ld	a,(iy-9)		; ch
	or	a
	jp	nz,L00146
; |>>> putch(10);
	ld	l,10
	push	hl
	call	_putch
	pop	af
L00146:
; |>>> break;
	jp	J00145
; |>>> default:
J00145_:
; |>>> l=EvalExpr(15,&Fl);
	push	iy
	pop	hl
	ld	a,l
	sub	7
	ld	l,a
	ld	a,h
	sbc	a,0
	ld	h,a		; addr. Fl
	push	hl
	ld	l,15
	push	hl
	call	_EvalExpr
	pop	af
	pop	af
	ld	(iy-16),l
	ld	(iy-15),h
	ld	(iy-14),e
	ld	(iy-13),d		; l
; |>>> if(fError)
	ld	a,(_fError)		; fError
	or	a
	jp	z,L00147
; |>>> goto myPrint;
	jp	myPrint_ExecStmt
L00147:
; |>>> if(!(Fl & 2)) {
	bit	1,(iy-7)
	jp	nz,L00148
; |>>> putch(l<0 ? '-' : ' ');
	bit	7,(iy-13)
	jp	z,L00149
	ld	l,45
	jr	L00149_
L00149:
	ld	l,32
L00149_:
	push	hl
	call	_putch
	pop	af
; |>>> if(Fl & 1) {
	bit	0,(iy-7)
	jp	z,L00150
; |>>> printf("%d",abs((int)l));
	ld	l,(iy-16)
	ld	h,(iy-15)		; l
	push	hl
	call	_abs
	pop	af
	push	hl
	ld	hl,L00151
	push	hl
	call	_printf
	pop	af
	pop	af
; |>>> else {
	jp	E00150
L00150:
; |>>> printf("%ld",labs(l));
	ld	l,(iy-16)
	ld	h,(iy-15)
	ld	e,(iy-14)
	ld	d,(iy-13)		; l
	push	de
	push	hl
	call	_labs
	pop	af
	pop	af
	push	de
	push	hl
	ld	hl,L00152
	push	hl
	call	_printf
	pop	af
	pop	af
	pop	af
E00150:
; |>>> else {
	jp	E00148
L00148:
; |>>> p=(char *)l;
	ld	l,(iy-16)
	ld	h,(iy-15)		; l
	ld	(iy-4),l
	ld	(iy-3),h		; p
; |>>> ch=*(((char *)&l)+2);
	push	iy
	pop	hl
	ld	a,l
	sub	16
	ld	l,a
	ld	a,h
	sbc	a,0
	ld	h,a		; addr. l
	inc	hl
	inc	hl
	ld	l,(hl)
	ld	(iy-9),l		; ch
; |>>> while(ch--)
J00153_:
	ld	l,(iy-9)
	dec	(iy-9)
	ld	a,l
	or	a
	jp	z,J00153
; |>>> putch(*p++);
	ld	l,(iy-4)
	ld	h,(iy-3)
	inc	(iy-4)
	jr	nz,$+5
	inc	(iy-3)
	ld	l,(hl)
	push	hl
	call	_putch
	pop	af
	jp 	J00153_
J00153:
E00148:
; |>>> ch=0;
	ld	(iy-9),0		; ch
; |>>> goto myPrint;
	jp	myPrint_ExecStmt
; |>>> break;
	jp	J00145
J00145:
L00144:
; |>>> break;  
	jp	J00132
; |>>> case '\x87':               |
J00132_87:
myRem_ExecStmt:
; |>>> TextP=CercaFine(0);
	xor	a
	ld	l,a
	push	hl
	call	_CercaFine
	pop	af
	ld	(_TextP),hl		; TextP
; |>>> break;
	jp	J00132
; |>>> case '\x88':               |
J00132_88:
; |>>> p=HandleVar(1,&Fl);
	push	iy
	pop	hl
	ld	a,l
	sub	7
	ld	l,a
	ld	a,h
	sbc	a,0
	ld	h,a		; addr. Fl
	push	hl
	ld	l,1
	push	hl
	call	_HandleVar
	pop	af
	pop	af
	ld	(iy-4),l
	ld	(iy-3),h		; p
; |>>> if(!fError) {
	ld	a,(_fError)		; fError
	or	a
	jp	nz,L00154
; |>>> OldVar=p;
	ld	l,(iy-4)
	ld	h,(iy-3)		; p
	ld	(iy-20),l
	ld	(iy-19),h		; OldVar
; |>>> if(Fl & 2) {
	bit	1,(iy-7)
	jp	z,L00155
; |>>> RetVal=4;
	ld	(iy-1),4		; RetVal
; |>>> goto myFor1;
	jp	myFor1_ExecStmt
L00155:
; |>>> if(DoCheck('='))
	ld	l,61
	push	hl
	call	_DoCheck
	pop	af
	ld	a,l
	or	a
	jp	z,L00156
; |>>> goto myFor1;
	jp	myFor1_ExecStmt
L00156:
; |>>> l=GetValue(0);
	xor	a
	ld	l,a
	push	hl
	call	_GetValue
	pop	af
	ld	(iy-16),l
	ld	(iy-15),h
	ld	(iy-14),e
	ld	(iy-13),d		; l
; |>>> *(long *)OldVar=l;
	ld	l,(iy-20)
	ld	h,(iy-19)		; OldVar
	ld	e,(iy-16)
	ld	d,(iy-15)
	ld	c,(iy-14)
	ld	b,(iy-13)		; l
	ld	(hl),e
	inc	hl
	ld	(hl),d
	inc	hl
	ld	(hl),c
	inc	hl
	ld	(hl),b
; |>>> if(DoCheck('\x89'))
	ld	l,137
	push	hl
	call	_DoCheck
	pop	af
	ld	a,l
	or	a
	jp	z,L00157
; |>>> goto myFor1;
	jp	myFor1_ExecStmt
L00157:
; |>>> ToVal=GetValue(0);
	xor	a
	ld	l,a
	push	hl
	call	_GetValue
	pop	af
	ld	(iy-24),l
	ld	(iy-23),h
	ld	(iy-22),e
	ld	(iy-21),d		; ToVal
; |>>> if(fError)
	ld	a,(_fError)		; fError
	or	a
	jp	z,L00158
; |>>> goto myFor1;
	jp	myFor1_ExecStmt
L00158:
; |>>> SkipSpaces();
	call	_SkipSpaces
; |>>> if(*TextP=='\x8a') {
	ld	hl,(_TextP)		; TextP
	ld	l,(hl)
	ld	a,l
	cp	138
	jp	nz,L00159
; |>>> TextP++;
	ld	hl,(_TextP)
	inc	hl
	ld	(_TextP),hl
; |>>> StVal=GetValue(0);
	xor	a
	ld	l,a
	push	hl
	call	_GetValue
	pop	af
	ld	(iy-28),l
	ld	(iy-27),h
	ld	(iy-26),e
	ld	(iy-25),d		; StVal
; |>>> if(fError)
	ld	a,(_fError)		; fError
	or	a
	jp	z,L00160
; |>>> goto myFor1;
	jp	myFor1_ExecStmt
L00160:
; |>>> else
	jp	E00159
L00159:
; |>>> StVal=1;
	ld	(iy-28),1
	ld	(iy-27),0
	ld	(iy-26),0
	ld	(iy-25),0		; StVal
E00159:
; |>>> OldText=TextP;
	ld	hl,(_TextP)		; TextP
	ld	(iy-18),l
	ld	(iy-17),h		; OldText
; |>>> for(;;) {
J00161_:
; |>>> ExecLine();
	call	_ExecLine
; |>>> SkipSpaces();
	call	_SkipSpaces
; |>>> if(*TextP && *TextP != ':')|
	ld	hl,(_TextP)		; TextP
	ld	a,(hl)
	or	a
	jp	z,L00162
	ld	hl,(_TextP)		; TextP
	ld	l,(hl)
	ld	a,l
	cp	58
	jp	z,L00162
; |>>> p=HandleVar(0,&Fl);
	push	iy
	pop	hl
	ld	a,l
	sub	7
	ld	l,a
	ld	a,h
	sbc	a,0
	ld	h,a		; addr. Fl
	push	hl
	xor	a
	ld	l,a
	push	hl
	call	_HandleVar
	pop	af
	pop	af
	ld	(iy-4),l
	ld	(iy-3),h		; p
; |>>> if(p != OldVar) {
	ld	l,(iy-4)
	ld	h,(iy-3)		; p
	ld	e,(iy-20)
	ld	d,(iy-19)		; OldVar
	ld	a,l
	cp	e
	jr	nz,J00164
	ld	a,h
	cp	d
J00164:
	jp	z,L00163
; |>>> RetVal=6;
	ld	(iy-1),6		; RetVal
; |>>> goto myFor2;
	jp	myFor2_ExecStmt
L00163:
L00162:
; |>>> p=TextP;
	ld	hl,(_TextP)		; TextP
	ld	(iy-4),l
	ld	(iy-3),h		; p
; |>>> TextP=OldText;
	ld	l,(iy-18)
	ld	h,(iy-17)		; OldText
	ld	(_TextP),hl		; TextP
; |>>> *(long *)OldVar+=StVal;
	ld	l,(iy-20)
	ld	h,(iy-19)		; OldVar
	ld	a,(hl)
	add	a,(iy-28)
	ld	(hl),a
	inc	hl
	ld	a,(hl)
	adc	a,(iy-27)
	ld	(hl),a
	inc	hl
	ld	a,(hl)
	adc	a,(iy-26)
	ld	(hl),a
	inc	hl
	ld	a,(hl)
	adc	a,(iy-25)
	ld	(hl),a
; |>>> if(StVal<0) {
	bit	7,(iy-25)
	jp	z,L00165
; |>>> if(*((long *)OldVar) < ToVa}
	ld	l,(iy-20)
	ld	h,(iy-19)		; OldVar
	ld	a,(hl)
	push	af
	inc	hl
	ld	a,(hl)
	inc	hl
	ld	e,(hl)
	inc	hl
	ld	d,(hl)
	ld	h,a
	pop	af
	ld	l,a
	push	hl
	push	de
	ld	l,(iy-24)
	ld	h,(iy-23)
	ld	e,(iy-22)
	ld	d,(iy-21)		; ToVal
	ld	(iy-32),l
	ld	(iy-31),h
	ld	(iy-30),e
	ld	(iy-29),d
	pop	de
	pop	hl
	ld	a,l
	sub	(iy-32)
	ld	a,h
	sbc	a,(iy-31)
	ld	a,e
	sbc	a,(iy-30)
	ld	a,d
	sbc	a,(iy-29)
	jp	p,L00166
; |>>> break;
	jp	J00161
L00166:
; |>>> else {
	jp	E00165
L00165:
; |>>> if(*((long *)OldVar) >= ToV}
	ld	l,(iy-20)
	ld	h,(iy-19)		; OldVar
	ld	a,(hl)
	push	af
	inc	hl
	ld	a,(hl)
	inc	hl
	ld	e,(hl)
	inc	hl
	ld	d,(hl)
	ld	h,a
	pop	af
	ld	l,a
	push	hl
	push	de
	ld	l,(iy-24)
	ld	h,(iy-23)
	ld	e,(iy-22)
	ld	d,(iy-21)		; ToVal
	ld	(iy-32),l
	ld	(iy-31),h
	ld	(iy-30),e
	ld	(iy-29),d
	pop	de
	pop	hl
	ld	a,l
	sub	(iy-32)
	ld	a,h
	sbc	a,(iy-31)
	ld	a,e
	sbc	a,(iy-30)
	ld	a,d
	sbc	a,(iy-29)
	jp	m,L00167
; |>>> break;
	jp	J00161
L00167:
E00165:
	jp 	J00161_
J00161:
; |>>> TextP=p;
	ld	l,(iy-4)
	ld	h,(iy-3)		; p
	ld	(_TextP),hl		; TextP
; |>>> else {
	jp	E00154
L00154:
myFor1_ExecStmt:
; |>>> RetVal=1;
	ld	(iy-1),1		; RetVal
E00154:
myFor2_ExecStmt:
; |>>> break;
	jp	J00132
; |>>> case '\x8b':
J00132_8b:
; |>>> RetVal=-6;
	ld	(iy-1),250		; RetVal
; |>>> break;
	jp	J00132
; |>>> case '\x8d':               |
J00132_8d:
; |>>> OldText=CercaFine(1);
	ld	l,1
	push	hl
	call	_CercaFine
	pop	af
	ld	(iy-18),l
	ld	(iy-17),h		; OldText
; |>>> RetVal=ExecStmt('\x8c');
	ld	l,140
	push	hl
	call	_ExecStmt
	pop	af
	ld	(iy-1),l		; RetVal
; |>>> ExecLine();
	call	_ExecLine
; |>>> TextP=OldText;
	ld	l,(iy-18)
	ld	h,(iy-17)		; OldText
	ld	(_TextP),hl		; TextP
; |>>> break;
	jp	J00132
; |>>> case '\x8c':               |
J00132_8c:
myGoto_ExecStmt:
; |>>> i=(int)GetValue(0);
	xor	a
	ld	l,a
	push	hl
	call	_GetValue
	pop	af
	ld	c,e
	ld	b,d
	ld	d,h
	ld	e,l
	push	hl
	pop	ix		; i
; |>>> if(p=CercaLine(i,0)) {
	xor	a
	ld	l,a
	push	hl
	push	ix
	call	_CercaLine
	pop	af
	pop	af
	ld	(iy-4),l
	ld	(iy-3),h		; p
	ld	a,l
	or	h
	jp	z,L00168
; |>>> TextP=p+4;
	ld	l,(iy-4)
	ld	h,(iy-3)		; p
	inc	hl
	inc	hl
	inc	hl
	inc	hl
	ld	(_TextP),hl		; TextP
; |>>> Linea=i;
	push	ix
	pop	hl		; i
	ld	(_Linea),hl		; Linea
; |>>> else
	jp	E00168
L00168:
; |>>> RetVal=3;
	ld	(iy-1),3		; RetVal
E00168:
; |>>> break;
	jp	J00132
; |>>> case '\x8e':               |
J00132_8e:
; |>>> RetVal=-5;
	ld	(iy-1),251		; RetVal
; |>>> break;
	jp	J00132
; |>>> case '\x8f':               |
J00132_8f:
; |>>> i=(int)GetValue(0);
	xor	a
	ld	l,a
	push	hl
	call	_GetValue
	pop	af
	ld	c,e
	ld	b,d
	ld	d,h
	ld	e,l
	push	hl
	pop	ix		; i
; |>>> if(i) {
	push	ix
	pop	hl
	ld	a,l
	or	h		; i
	jp	z,L00169
; |>>> DoCheck('\x90');
	ld	l,144
	push	hl
	call	_DoCheck
	pop	af
; |>>> else {
	jp	E00169
L00169:
; |>>> goto myRem;
	jp	myRem_ExecStmt
E00169:
; |>>> break;
	jp	J00132
; |>>> case '\x92':               |
J00132_92:
; |>>> i=(int)GetValue(0);
	xor	a
	ld	l,a
	push	hl
	call	_GetValue
	pop	af
	ld	c,e
	ld	b,d
	ld	d,h
	ld	e,l
	push	hl
	pop	ix		; i
; |>>> DoCheck('\x8c');
	ld	l,140
	push	hl
	call	_DoCheck
	pop	af
; |>>> if(i<0)
	push	ix
	pop	hl		; i
	bit	7,l
	jp	z,L00170
; |>>> RetVal=2;
	ld	(iy-1),2		; RetVal
	jp	E00170
L00170:
; |>>> else {
; |>>> if(!i)
	push	ix
	pop	hl
	ld	a,l
	or	h		; i
	jp	nz,L00171
; |>>> goto myRem;
	jp	myRem_ExecStmt
L00171:
; |>>> while(--i) {
J00172_:
	dec	ix
	push	ix
	pop	hl
	ld	a,l
	or	h
	jp	z,J00172
; |>>> GetValue(0);
	xor	a
	ld	l,a
	push	hl
	call	_GetValue
	pop	af
; |>>> DoCheck(',');
	ld	l,44
	push	hl
	call	_DoCheck
	pop	af
	jp 	J00172_
J00172:
; |>>> goto myGoto;  
	jp	myGoto_ExecStmt
E00170:
; |>>> break;
	jp	J00132
; |>>> case '\x93':               |
J00132_93:
; |>>> i=(int)GetValue(0);
	xor	a
	ld	l,a
	push	hl
	call	_GetValue
	pop	af
	ld	c,e
	ld	b,d
	ld	d,h
	ld	e,l
	push	hl
	pop	ix		; i
; |>>> _asm {
	 jp( hl)
; |>>> break;
	jp	J00132
; |>>> case '\x94':               |
J00132_94:
; |>>> p=(char *)GetValue(0);
	xor	a
	ld	l,a
	push	hl
	call	_GetValue
	pop	af
	ld	c,e
	ld	b,d
	ld	d,h
	ld	e,l
	ld	(iy-4),l
	ld	(iy-3),h		; p
; |>>> DoCheck(',');
	ld	l,44
	push	hl
	call	_DoCheck
	pop	af
; |>>> i=(int)GetValue(0);
	xor	a
	ld	l,a
	push	hl
	call	_GetValue
	pop	af
	ld	c,e
	ld	b,d
	ld	d,h
	ld	e,l
	push	hl
	pop	ix		; i
; |>>> *p=i;
	ld	l,(iy-4)
	ld	h,(iy-3)		; p
	push	ix
	pop	de		; i
	ld	(hl),e
; |>>> break;
	jp	J00132
; |>>> case '\x95':               |
J00132_95:
; |>>> i=(int)GetValue(0);
	xor	a
	ld	l,a
	push	hl
	call	_GetValue
	pop	af
	ld	c,e
	ld	b,d
	ld	d,h
	ld	e,l
	push	hl
	pop	ix		; i
; |>>> DoCheck(',');
	ld	l,44
	push	hl
	call	_DoCheck
	pop	af
; |>>> i1=(int)GetValue(0);
	xor	a
	ld	l,a
	push	hl
	call	_GetValue
	pop	af
	ld	c,e
	ld	b,d
	ld	d,h
	ld	e,l
	ld	(iy-12),l
	ld	(iy-11),h		; i1
; |>>> outp(i,i1);
	ld	l,(iy-12)		; i1
	push	hl
	push	ix
	call	_outp
	pop	af
	pop	af
; |>>> break;
	jp	J00132
; |>>> case '\x96':               |
J00132_96:
; |>>> SkipSpaces();
	call	_SkipSpaces
; |>>> if(*TextP=='\"') {
	ld	hl,(_TextP)		; TextP
	ld	l,(hl)
	ld	a,l
	cp	34
	jp	nz,L00173
; |>>> TextP++;
	ld	hl,(_TextP)
	inc	hl
	ld	(_TextP),hl
; |>>> while(*TextP != '\"') {
J00174_:
	ld	hl,(_TextP)		; TextP
	ld	l,(hl)
	ld	a,l
	cp	34
	jp	z,J00174
; |>>> putch(*TextP++);
	ld	de,(_TextP)
	ld	l,e
	ld	h,d
	inc	de
	ld	(_TextP),de
	ld	l,(hl)
	push	hl
	call	_putch
	pop	af
	jp 	J00174_
J00174:
; |>>> TextP++;
	ld	hl,(_TextP)
	inc	hl
	ld	(_TextP),hl
; |>>> DoCheck(';');
	ld	l,59
	push	hl
	call	_DoCheck
	pop	af
L00173:
; |>>> p=HandleVar(1,&Fl);
	push	iy
	pop	hl
	ld	a,l
	sub	7
	ld	l,a
	ld	a,h
	sbc	a,0
	ld	h,a		; addr. Fl
	push	hl
	ld	l,1
	push	hl
	call	_HandleVar
	pop	af
	pop	af
	ld	(iy-4),l
	ld	(iy-3),h		; p
; |>>> if(!fError) {
	ld	a,(_fError)		; fError
	or	a
	jp	nz,L00175
; |>>> putch('?');
	ld	l,63
	push	hl
	call	_putch
	pop	af
; |>>> putch(' ');
	ld	l,32
	push	hl
	call	_putch
	pop	af
; |>>> scanf("%s",DirectBuf);
	ld	hl,_DirectBuf		; DirectBuf
	push	hl
	ld	hl,L00176
	push	hl
	call	_scanf
	pop	af
	pop	af
; |>>> if(Fl & 2) {
	bit	1,(iy-7)
	jp	z,L00177
; |>>> i=strlen(DirectBuf);
	ld	hl,_DirectBuf		; DirectBuf
	push	hl
	call	_strlen
	pop	af
	push	hl
	pop	ix		; i
; |>>> p1=AllocaString(i);
	push	ix
	call	_AllocaString
	pop	af
	ld	(iy-6),l
	ld	(iy-5),h		; p1
; |>>> if(p1) {
	ld	a,(iy-6)
	or	(iy-5)		; p1
	jp	z,L00178
; |>>> *(char **)p=p1;
	ld	l,(iy-4)
	ld	h,(iy-3)		; p
	ld	e,(iy-6)
	ld	d,(iy-5)		; p1
	ld	(hl),e
	inc	hl
	ld	(hl),d
; |>>> *(((int *)p)+1)=i;
	ld	l,(iy-4)
	ld	h,(iy-3)		; p
	inc	hl
	inc	hl
	push	ix
	pop	de		; i
	ld	(hl),e
	inc	hl
	ld	(hl),d
; |>>> memmove(p1,DirectBuf,i);
	push	ix
	ld	hl,_DirectBuf		; DirectBuf
	push	hl
	ld	l,(iy-6)
	ld	h,(iy-5)		; p1
	push	hl
	call	_memmove
	pop	af
	pop	af
	pop	af
L00178:
; |>>> else {
	jp	E00177
L00177:
; |>>> if(Fl & 1) {
	bit	0,(iy-7)
	jp	z,L00179
; |>>> *(int *)p=atoi(DirectBuf);|
	ld	l,(iy-4)
	ld	h,(iy-3)		; p
	push	hl
	ld	de,_DirectBuf		; DirectBuf
	push	de
	call	_atoi
	pop	af
	ld	d,h
	ld	e,l
	pop	hl
	ld	(hl),e
	inc	hl
	ld	(hl),d
; |>>> else
	jp	E00179
L00179:
; |>>> *(long *)p=atol(DirectBuf);|
	ld	l,(iy-4)
	ld	h,(iy-3)		; p
	push	hl
	ld	de,_DirectBuf		; DirectBuf
	push	de
	call	_atol
	pop	af
	ld	c,e
	ld	b,d
	ld	d,h
	ld	e,l
	pop	hl
	ld	(hl),e
	inc	hl
	ld	(hl),d
	inc	hl
	ld	(hl),c
	inc	hl
	ld	(hl),b
E00179:
E00177:
L00175:
; |>>> break;
	jp	J00132
; |>>> case '\x97':               |
J00132_97:
; |>>> p=HandleVar(1,&Fl);
	push	iy
	pop	hl
	ld	a,l
	sub	7
	ld	l,a
	ld	a,h
	sbc	a,0
	ld	h,a		; addr. Fl
	push	hl
	ld	l,1
	push	hl
	call	_HandleVar
	pop	af
	pop	af
	ld	(iy-4),l
	ld	(iy-3),h		; p
; |>>> if(!fError) {
	ld	a,(_fError)		; fError
	or	a
	jp	nz,L00180
; |>>> if(Fl & 2) {
	bit	1,(iy-7)
	jp	z,L00181
; |>>> if(kbhit()) {
	call	_kbhit
	ld	a,l
	or	a
	jp	z,L00182
; |>>> ch=getch();
	call	_getch
	ld	(iy-9),l		; ch
; |>>> p1=AllocaString(1);
	ld	hl,1
	push	hl
	call	_AllocaString
	pop	af
	ld	(iy-6),l
	ld	(iy-5),h		; p1
; |>>> if(p1) {
	ld	a,(iy-6)
	or	(iy-5)		; p1
	jp	z,L00183
; |>>> *(char **)p=p1;
	ld	l,(iy-4)
	ld	h,(iy-3)		; p
	ld	e,(iy-6)
	ld	d,(iy-5)		; p1
	ld	(hl),e
	inc	hl
	ld	(hl),d
; |>>> *(((int *)p)+1)=1;
	ld	l,(iy-4)
	ld	h,(iy-3)		; p
	inc	hl
	inc	hl
	ld	(hl),1
	inc	hl
	ld	(hl),0
; |>>> *p1=ch;
	ld	l,(iy-6)
	ld	h,(iy-5)		; p1
	ld	e,(iy-9)		; ch
	ld	(hl),e
L00183:
; |>>> else {
	jp	E00182
L00182:
; |>>> *(char **)p=StrBase;
	ld	l,(iy-4)
	ld	h,(iy-3)		; p
	ld	de,(_StrBase)		; StrBase
	ld	(hl),e
	inc	hl
	ld	(hl),d
; |>>> *(((int *)p)+1)=0;
	ld	l,(iy-4)
	ld	h,(iy-3)		; p
	inc	hl
	inc	hl
	ld	(hl),0
	inc	hl
	ld	(hl),0
E00182:
; |>>> else
	jp	E00181
L00181:
; |>>> fError=4;
	ld	l,4
	ld	a,l
	ld	(_fError),a		; fError
E00181:
L00180:
; |>>> break;
	jp	J00132
; |>>> case '\x98':
J00132_98:
; |>>> cls();
	call	_cls
; |>>> break;
	jp	J00132
; |>>> case '\x99':
J00132_99:
; |>>> putch(7);
	ld	l,7
	push	hl
	call	_putch
	pop	af
; |>>> break;
	jp	J00132
; |>>> case '\x9a':               |
J00132_9a:
; |>>> break;
	jp	J00132
; |>>> case '\x9b':               |
J00132_9b:
; |>>> *(int *)PrgBase=PrgBase+2; |
	ld	hl,(_PrgBase)		; PrgBase
	ld	de,(_PrgBase)		; PrgBase
	inc	de
	inc	de
	ld	(hl),e
	inc	hl
	ld	(hl),d
; |>>> RelinkBasic();
	call	_RelinkBasic
; |>>> break;
	jp	J00132
; |>>> case ':':
J00132_3a:
; |>>> case ' ':
J00132_20:
; |>>> break;
	jp	J00132
; |>>> default:
J00132_:
; |>>> TextP--;
	ld	hl,(_TextP)
	dec	hl
	ld	(_TextP),hl
; |>>> p=HandleVar(1,&Fl);
	push	iy
	pop	hl
	ld	a,l
	sub	7
	ld	l,a
	ld	a,h
	sbc	a,0
	ld	h,a		; addr. Fl
	push	hl
	ld	l,1
	push	hl
	call	_HandleVar
	pop	af
	pop	af
	ld	(iy-4),l
	ld	(iy-3),h		; p
; |>>> if(!fError) {
	ld	a,(_fError)		; fError
	or	a
	jp	nz,L00184
; |>>> DoCheck('=');
	ld	l,61
	push	hl
	call	_DoCheck
	pop	af
; |>>> l=EvalExpr(15,&Fl1);
	push	iy
	pop	hl
	ld	a,l
	sub	8
	ld	l,a
	ld	a,h
	sbc	a,0
	ld	h,a		; addr. Fl1
	push	hl
	ld	l,15
	push	hl
	call	_EvalExpr
	pop	af
	pop	af
	ld	(iy-16),l
	ld	(iy-15),h
	ld	(iy-14),e
	ld	(iy-13),d		; l
; |>>> if(fError) {
	ld	a,(_fError)		; fError
	or	a
	jp	z,L00185
; |>>> goto myLet2;
	jp	myLet2_ExecStmt
L00185:
; |>>> if(Fl & 2) {
	bit	1,(iy-7)
	jp	z,L00186
; |>>> if(!(Fl1 & 2)) {
	bit	1,(iy-8)
	jp	nz,L00187
; |>>> RetVal=4;
	ld	(iy-1),4		; RetVal
; |>>> else {
	jp	E00187
L00187:
; |>>> *(long *)p=l;
	ld	l,(iy-4)
	ld	h,(iy-3)		; p
	ld	e,(iy-16)
	ld	d,(iy-15)
	ld	c,(iy-14)
	ld	b,(iy-13)		; l
	ld	(hl),e
	inc	hl
	ld	(hl),d
	inc	hl
	ld	(hl),c
	inc	hl
	ld	(hl),b
E00187:
; |>>> else {
	jp	E00186
L00186:
; |>>> if(Fl1 & 2) {
	bit	1,(iy-8)
	jp	z,L00188
; |>>> RetVal=4;
	ld	(iy-1),4		; RetVal
; |>>> else {
	jp	E00188
L00188:
; |>>> if(Fl & 1) {
	bit	0,(iy-7)
	jp	z,L00189
; |>>> *(int *)p=l;
	ld	l,(iy-4)
	ld	h,(iy-3)		; p
	ld	e,(iy-16)
	ld	d,(iy-15)		; l
	ld	(hl),e
	inc	hl
	ld	(hl),d
; |>>> else {
	jp	E00189
L00189:
; |>>> *(long *)p=l;
	ld	l,(iy-4)
	ld	h,(iy-3)		; p
	ld	e,(iy-16)
	ld	d,(iy-15)
	ld	c,(iy-14)
	ld	b,(iy-13)		; l
	ld	(hl),e
	inc	hl
	ld	(hl),d
	inc	hl
	ld	(hl),c
	inc	hl
	ld	(hl),b
E00189:
E00188:
E00186:
; |>>> else {
	jp	E00184
L00184:
myLet2_ExecStmt:
; |>>> RetVal=1;
	ld	(iy-1),1		; RetVal
E00184:
; |>>> break;
	jp	J00132
J00132:
; |>>> return RetVal;
	ld	l,(iy-1)		; RetVal
	jp	R00190
R00190:
	pop	ix
	ld	sp,iy
	pop	iy
	ret
_ExecStmt	endp
; --------------------------------}

; |--- char ExecLine() {

public	_ExecLine
_ExecLine	proc
	push	iy
	ld	iy,0
	add	iy,sp
	push	af
	push	af
	push	af
; |--- char *p;
; p = -2
; |--- char RetVal=0;
; RetVal = -3
	ld	(iy-3),0		; RetVal
; |--- int i;
; i = -6
rifo_ExecLine:
; |>>> if(!DirectMode)
	ld	a,(_DirectMode)		; DirectMode
	or	a
	jp	nz,L00191
; |>>> Linea=*(int *)(TextP-2);
	ld	hl,(_TextP)		; TextP
	dec	hl
	dec	hl
	ld	a,(hl)
	inc	hl
	ld	h,(hl)
	ld	l,a
	ld	(_Linea),hl		; Linea
L00191:
; |>>> while(*TextP && !RetVal) {|
J00192_:
	ld	hl,(_TextP)		; TextP
	ld	a,(hl)
	or	a
	jp	z,J00192
	ld	a,(iy-3)		; RetVal
	or	a
	jp	nz,J00192
; |>>> RetVal=ExecStmt(*TextP++);|
	ld	de,(_TextP)
	ld	l,e
	ld	h,d
	inc	de
	ld	(_TextP),de
	ld	l,(hl)
	push	hl
	call	_ExecStmt
	pop	af
	ld	(iy-3),l		; RetVal
; |>>> _asm {
	 ld e, 41
	 rst 8
; |>>> if(isBreak())
	call	_isBreak
	ld	a,l
	or	a
	jp	z,L00193
; |>>> RetVal=17;
	ld	(iy-3),17		; RetVal
L00193:
; |>>> if(fError)
	ld	a,(_fError)		; fError
	or	a
	jp	z,L00194
; |>>> RetVal=fError;
	ld	hl,(_fError)		; fError
	ld	(iy-3),l		; RetVal
L00194:
	jp 	J00192_
J00192:
; |>>> if(RetVal)
	ld	a,(iy-3)		; RetVal
	or	a
	jp	z,L00195
; |>>> return RetVal;
	ld	l,(iy-3)		; RetVal
	jp	R00196
L00195:
; |>>> if(!DirectMode) {
	ld	a,(_DirectMode)		; DirectMode
	or	a
	jp	nz,L00197
; |>>> TextP++;
	ld	hl,(_TextP)
	inc	hl
	ld	(_TextP),hl
; |>>> if(*(int *)TextP) {
	ld	hl,(_TextP)		; TextP
	ld	a,(hl)
	inc	hl
	or	(hl)
	jp	z,L00198
; |>>> TextP+=4;
	ld	hl,(_TextP)		; TextP
	inc	hl
	inc	hl
	inc	hl
	inc	hl
	ld	(_TextP),hl		; TextP
; |>>> goto rifo;
	jp	rifo_ExecLine
L00198:
L00197:
; |>>> return 0;
	xor	a
	ld	l,a
	jp	R00196
R00196:
	ld	sp,iy
	pop	iy
	ret
_ExecLine	endp
; --------------------------------}

; |--- char *CercaLine(int n, char|

public	_CercaLine
_CercaLine	proc
	push	iy
	ld	iy,0
	add	iy,sp
	push	af
	push	ix
; n = 4
; m = 6
; |--- register char **p,*p1;
; register ix = p
; p1 = -2
; --------------------------------|
; |>>> p=PrgBase;
	ld	ix,(_PrgBase)		; p
; |>>> while(p1=*p) {
J00199_:
	ld	l,(ix+0)
	ld	h,(ix+1)
	ld	(iy-2),l
	ld	(iy-1),h		; p1
	ld	a,l
	or	h
	jp	z,J00199
; |>>> if(p[1] == n)
	ld	l,(ix+2)
	ld	h,(ix+3)
	ld	e,(iy+4)
	ld	d,(iy+5)		; n
	ld	a,l
	cp	e
	jr	nz,J00201
	ld	a,h
	cp	d
J00201:
	jp	nz,L00200
; |>>> return p;
	push	ix
	pop	hl		; p
	jp	R00202
L00200:
; |>>> if(m) {
	ld	a,(iy+6)		; m
	or	a
	jp	z,L00203
; |>>> if(p[1] >= n)
	ld	l,(ix+2)
	ld	h,(ix+3)
	ld	e,(iy+4)
	ld	d,(iy+5)		; n
	ld	a,l
	sub	e
	ld	a,h
	sbc	a,d
	jp	m,L00204
; |>>> return p;
	push	ix
	pop	hl		; p
	jp	R00202
L00204:
L00203:
; |>>> p=p1;
	ld	l,(iy-2)
	ld	h,(iy-1)		; p1
	push	hl
	pop	ix		; p
	jp 	J00199_
J00199:
; |>>> return 0;
	ld	hl,0
	jp	R00202
R00202:
	pop	ix
	pop	af
	pop	iy
	ret
_CercaLine	endp
; --------------------------------}

; |--- char *CercaFine(char m) {

public	_CercaFine
_CercaFine	proc
	push	iy
	ld	iy,0
	add	iy,sp
	push	ix
; m = 4
; |--- register char *p;
; register ix = p
; --------------------------------|
; |>>> p=TextP;
	ld	ix,(_TextP)		; p
; |>>> while(*p) {
J00205_:
	ld	a,(ix+0)
	or	a
	jp	z,J00205
; |>>> if(m && *p==':')
	ld	a,(iy+4)		; m
	or	a
	jp	z,L00206
	ld	l,(ix+0)
	ld	a,l
	cp	58
	jp	nz,L00206
; |>>> break;
	jp	J00205
L00206:
; |>>> p++;
	inc	ix
	jp 	J00205_
J00205:
; |>>> return p;
	push	ix
	pop	hl		; p
	jp	R00207
R00207:
	pop	ix
	pop	iy
	ret
_CercaFine	endp
; --------------------------------}

; |--- char GetAritmElem(register `

public	_GetAritmElem
_GetAritmElem	proc
	push	iy
	ld	iy,-16
	add	iy,sp
	ld	sp,iy
	ld	iy,16
	add	iy,sp
	push	ix
; register ix = l
	ld	l,(iy+4)
	ld	h,(iy+5)
	push	hl
	pop	ix
; |--- char *p;
; p = -2
; |--- char ch,Fl;
; ch = -3
; Fl = -4
; |--- int i,j,i1;
; i = -6
; j = -8
; i1 = -10
; |--- long l1;
; l1 = -14
; |--- char RetVal;
; RetVal = -15
rifo_GetAritmElem:
; --------------------------------|
; |>>> ch=*TextP;
	ld	hl,(_TextP)		; TextP
	ld	l,(hl)
	ld	(iy-3),l		; ch
; |>>> if(ch >= '0' && ch < ('9'+1|
	ld	a,(iy-3)
	cp	48
	jp	m,L00209
	ld	a,(iy-3)
	cp	58
	jp	m,L00210
L00209:
	ld	a,(iy-3)
	cp	46
	jp	nz,L00208
L00210:
; |>>> *l=myAtoi();
	push	hl
	call	_myAtoi
	ld	c,e
	ld	b,d
	ld	d,h
	ld	e,l
	pop	hl
	ld	(ix+0),e
	ld	(ix+1),d
	ld	(ix+2),c
	ld	(ix+3),b
; |>>> if(*TextP=='%') {
	ld	hl,(_TextP)		; TextP
	ld	l,(hl)
	ld	a,l
	cp	37
	jp	nz,L00211
; |>>> TextP++;
	ld	hl,(_TextP)
	inc	hl
	ld	(_TextP),hl
; |>>> return 1;
	ld	l,1
	jp	R00212
; |>>> else  
	jp	E00211
L00211:
; |>>> return 0;
	xor	a
	ld	l,a
	jp	R00212
E00211:
; |>>> else if(ch < 0) {          |
	jp	E00208
L00208:
; |>>> if(ch < 0) {               |
	ld	a,(iy-3)
	or	a
	jp	p,L00213
; |>>> ch &= 0x3f;
	ld	a,(iy-3)
	and	63
	ld	(iy-3),a
; |>>> TextP++;
	ld	hl,(_TextP)
	inc	hl
	ld	(_TextP),hl
; |>>> DoCheck('(');
	ld	l,40
	push	hl
	call	_DoCheck
	pop	af
; |>>> switch(ch) {
	ld	l,(iy-3)		; ch
	ld	a,l
	sub	2
	jp	m,J00214
	cp	23
	jp	p,J00214
	ld	l,a
	ld	h,0
	ld	de,J00214_T
	add	hl,hl
	add	hl,de
	ld	a,(hl)
	inc	hl
	ld	h,(hl)
	ld	l,a
	jp	(hl)
J00214_T:
dw	J00214_2
dw	J00214_3
dw	J00214_4
dw	J00214_5
dw	J00214_6
dw	J00214_7
dw	J00214_8
dw	J00214_9
dw	J00214_a
dw	J00214_b
dw	J00214_c
dw	J00214_d
dw	J00214_e
dw	J00214_f
dw	J00214_10
dw	J00214_11
dw	J00214_12
dw	J00214_13
dw	J00214_14
dw	J00214_15
dw	J00214
dw	J00214
dw	J00214_18
; |>>> case 2:                    |
J00214_2:
; |>>> l1=GetValue(0);
	xor	a
	ld	l,a
	push	hl
	call	_GetValue
	pop	af
	ld	(iy-14),l
	ld	(iy-13),h
	ld	(iy-12),e
	ld	(iy-11),d		; l1
; |>>> *l=(!l1) ? 1 : 0;
	ld	e,(iy-14)
	ld	d,(iy-13)
	ld	c,(iy-12)
	ld	b,(iy-11)		; l1
	ld	a,e
	or	d
	or	c
	or	b
	ld	e,0
	ld	d,e
	jr	nz,$+3
	inc	e
	ld	a,e
	or	d
	jp	z,L00215
	ld	de,1
	jr	L00215_
L00215:
	ld	de,0
L00215_:
	ld	a,d
	sla	a
	sbc	a,a
	ld	c,a
	ld	b,c
	ld	(ix+0),e
	ld	(ix+1),d
	ld	(ix+2),c
	ld	(ix+3),b
; |>>> RetVal=1;
	ld	(iy-15),1		; RetVal
; |>>> break;
	jp	J00214
; |>>> case 3:                    |
J00214_3:
; |>>> l1=GetValue(0);
	xor	a
	ld	l,a
	push	hl
	call	_GetValue
	pop	af
	ld	(iy-14),l
	ld	(iy-13),h
	ld	(iy-12),e
	ld	(iy-11),d		; l1
; |>>> if(l1)
	ld	a,(iy-14)
	or	(iy-13)
	or	(iy-12)
	or	(iy-11)		; l1
	jp	z,L00216
; |>>> *l=(l1 >= 0) ? 1 : -1;
	bit	7,(iy-11)
	jp	nz,L00217
	ld	de,1
	jr	L00217_
L00217:
	ld	de,-1
L00217_:
	ld	a,d
	sla	a
	sbc	a,a
	ld	c,a
	ld	b,c
	ld	(ix+0),e
	ld	(ix+1),d
	ld	(ix+2),c
	ld	(ix+3),b
	jp	E00216
L00216:
; |>>> else
; |>>> *l=0;
	ld	(ix+0),0
	ld	(ix+1),0
	ld	(ix+2),0
	ld	(ix+3),0
E00216:
; |>>> RetVal=1;
	ld	(iy-15),1		; RetVal
; |>>> break;
	jp	J00214
; |>>> case 4:                    |
J00214_4:
; |>>> l1=GetValue(0);
	xor	a
	ld	l,a
	push	hl
	call	_GetValue
	pop	af
	ld	(iy-14),l
	ld	(iy-13),h
	ld	(iy-12),e
	ld	(iy-11),d		; l1
; |>>> *l=labs(l1);
	push	hl
	ld	e,(iy-14)
	ld	d,(iy-13)
	ld	c,(iy-12)
	ld	b,(iy-11)		; l1
	push	bc
	push	de
	call	_labs
	pop	af
	pop	af
	ld	c,e
	ld	b,d
	ld	d,h
	ld	e,l
	pop	hl
	ld	(ix+0),e
	ld	(ix+1),d
	ld	(ix+2),c
	ld	(ix+3),b
; |>>> RetVal=0;
	ld	(iy-15),0		; RetVal
; |>>> break;
	jp	J00214
; |>>> case 5:                    |
J00214_5:
; |>>> l1=GetValue(0);
	xor	a
	ld	l,a
	push	hl
	call	_GetValue
	pop	af
	ld	(iy-14),l
	ld	(iy-13),h
	ld	(iy-12),e
	ld	(iy-11),d		; l1
; |>>> *l=l1;
	ld	e,(iy-14)
	ld	d,(iy-13)
	ld	c,(iy-12)
	ld	b,(iy-11)		; l1
	ld	(ix+0),e
	ld	(ix+1),d
	ld	(ix+2),c
	ld	(ix+3),b
; |>>> RetVal=0;
	ld	(iy-15),0		; RetVal
; |>>> break;
	jp	J00214
; |>>> case 6:                    |
J00214_6:
; |>>> l1=GetValue(0);
	xor	a
	ld	l,a
	push	hl
	call	_GetValue
	pop	af
	ld	(iy-14),l
	ld	(iy-13),h
	ld	(iy-12),e
	ld	(iy-11),d		; l1
; |>>> *l=sqrt(l1);
	push	hl
	ld	e,(iy-14)
	ld	d,(iy-13)		; l1
	push	bc
	push	de
	call	_sqrt
	pop	af
	pop	af
	ld	d,h
	ld	e,l
	pop	hl
	ld	a,d
	sla	a
	sbc	a,a
	ld	c,a
	ld	b,c
	ld	(ix+0),e
	ld	(ix+1),d
	ld	(ix+2),c
	ld	(ix+3),b
; |>>> RetVal=0;
	ld	(iy-15),0		; RetVal
; |>>> break;
	jp	J00214
; |>>> case 7:                    |
J00214_7:
; |>>> l1=GetValue(0);
	xor	a
	ld	l,a
	push	hl
	call	_GetValue
	pop	af
	ld	(iy-14),l
	ld	(iy-13),h
	ld	(iy-12),e
	ld	(iy-11),d		; l1
; |>>> *l=sin(l1);                |
	push	hl
	ld	e,(iy-14)
	ld	d,(iy-13)		; l1
	push	bc
	push	de
	call	_sin
	pop	af
	pop	af
	ld	d,h
	ld	e,l
	pop	hl
	ld	a,d
	sla	a
	sbc	a,a
	ld	c,a
	ld	b,c
	ld	(ix+0),e
	ld	(ix+1),d
	ld	(ix+2),c
	ld	(ix+3),b
; |>>> RetVal=0;
	ld	(iy-15),0		; RetVal
; |>>> break;
	jp	J00214
; |>>> case 8:
J00214_8:
; |>>> l1=GetValue(0);
	xor	a
	ld	l,a
	push	hl
	call	_GetValue
	pop	af
	ld	(iy-14),l
	ld	(iy-13),h
	ld	(iy-12),e
	ld	(iy-11),d		; l1
; |>>> *l=cos(l1);
	push	hl
	ld	e,(iy-14)
	ld	d,(iy-13)		; l1
	push	bc
	push	de
	call	_cos
	pop	af
	pop	af
	ld	d,h
	ld	e,l
	pop	hl
	ld	a,d
	sla	a
	sbc	a,a
	ld	c,a
	ld	b,c
	ld	(ix+0),e
	ld	(ix+1),d
	ld	(ix+2),c
	ld	(ix+3),b
; |>>> RetVal=0;
	ld	(iy-15),0		; RetVal
; |>>> break;
	jp	J00214
; |>>> case 9:
J00214_9:
; |>>> l1=GetValue(0);
	xor	a
	ld	l,a
	push	hl
	call	_GetValue
	pop	af
	ld	(iy-14),l
	ld	(iy-13),h
	ld	(iy-12),e
	ld	(iy-11),d		; l1
; |>>> *l=tan(l1);
	push	hl
	ld	e,(iy-14)
	ld	d,(iy-13)		; l1
	push	bc
	push	de
	call	_tan
	pop	af
	pop	af
	ld	d,h
	ld	e,l
	pop	hl
	ld	a,d
	sla	a
	sbc	a,a
	ld	c,a
	ld	b,c
	ld	(ix+0),e
	ld	(ix+1),d
	ld	(ix+2),c
	ld	(ix+3),b
; |>>> RetVal=0;
	ld	(iy-15),0		; RetVal
; |>>> break;
	jp	J00214
; |>>> case 10:
J00214_a:
; |>>> l1=GetValue(0);
	xor	a
	ld	l,a
	push	hl
	call	_GetValue
	pop	af
	ld	(iy-14),l
	ld	(iy-13),h
	ld	(iy-12),e
	ld	(iy-11),d		; l1
; |>>> *l=log(l1);
	push	hl
	ld	e,(iy-14)
	ld	d,(iy-13)		; l1
	push	bc
	push	de
	call	_log
	pop	af
	pop	af
	ld	d,h
	ld	e,l
	pop	hl
	ld	a,d
	sla	a
	sbc	a,a
	ld	c,a
	ld	b,c
	ld	(ix+0),e
	ld	(ix+1),d
	ld	(ix+2),c
	ld	(ix+3),b
; |>>> RetVal=0;
	ld	(iy-15),0		; RetVal
; |>>> break;
	jp	J00214
; |>>> case 11:
J00214_b:
; |>>> l1=GetValue(0);
	xor	a
	ld	l,a
	push	hl
	call	_GetValue
	pop	af
	ld	(iy-14),l
	ld	(iy-13),h
	ld	(iy-12),e
	ld	(iy-11),d		; l1
; |>>> *l=exp(l1);
	push	hl
	ld	e,(iy-14)
	ld	d,(iy-13)		; l1
	push	bc
	push	de
	call	_exp
	pop	af
	pop	af
	ld	d,h
	ld	e,l
	pop	hl
	ld	a,d
	sla	a
	sbc	a,a
	ld	c,a
	ld	b,c
	ld	(ix+0),e
	ld	(ix+1),d
	ld	(ix+2),c
	ld	(ix+3),b
; |>>> RetVal=0;
	ld	(iy-15),0		; RetVal
; |>>> break;
	jp	J00214
; |>>> case 12:                   |
J00214_c:
; |>>> *l=(unsigned long)(StrBase-|
	ld	de,(_StrBase)		; StrBase
	ld	bc,(_VarEnd)		; VarEnd
	ld	a,e
	sub	c
	ld	e,a
	ld	a,d
	sbc	a,b
	ld	d,a
	ld	c,0
	ld	b,c
	ld	(ix+0),e
	ld	(ix+1),d
	ld	(ix+2),c
	ld	(ix+3),b
; |>>> RetVal=1;
	ld	(iy-15),1		; RetVal
; |>>> break;
	jp	J00214
; |>>> case 13:                   |
J00214_d:
; |>>> i=GetValue(0);
	xor	a
	ld	l,a
	push	hl
	call	_GetValue
	pop	af
	ld	(iy-6),l
	ld	(iy-5),h		; i
; |>>> if(i<0) {
	bit	7,(iy-5)
	jp	z,L00218
; |>>> srand(i);
	ld	l,(iy-6)
	ld	h,(iy-5)		; i
	push	hl
	call	_srand
	pop	af
L00218:
; |>>> *l=(unsigned long)rand();
	push	hl
	call	_rand
	ld	d,h
	ld	e,l
	pop	hl
	ld	c,0
	ld	b,c
	ld	(ix+0),e
	ld	(ix+1),d
	ld	(ix+2),c
	ld	(ix+3),b
; |>>> RetVal=0;
	ld	(iy-15),0		; RetVal
; |>>> break;
	jp	J00214
; |>>> case 14:                   `
J00214_e:
; |>>> i=GetValue(0);
	xor	a
	ld	l,a
	push	hl
	call	_GetValue
	pop	af
	ld	(iy-6),l
	ld	(iy-5),h		; i
; |>>> *l=(unsigned long)*((unsign`
	ld	e,(iy-6)
	ld	d,(iy-5)		; i
	ld	a,(de)
	ld	e,a
	ld	d,0
	ld	c,d
	ld	b,d
	ld	(ix+0),e
	ld	(ix+1),d
	ld	(ix+2),c
	ld	(ix+3),b
; |>>> RetVal=1;
	ld	(iy-15),1		; RetVal
; |>>> break;
	jp	J00214
; |>>> case 15:                   `
J00214_f:
; |>>> i=GetValue(0);
	xor	a
	ld	l,a
	push	hl
	call	_GetValue
	pop	af
	ld	(iy-6),l
	ld	(iy-5),h		; i
; |>>> if(i<0 || i>255) {
	bit	7,(iy-5)
	jp	nz,L00220
	ld	a,(iy-6)
	scf
	sbc	a,255
	ld	a,(iy-5)
	sbc	a,0
	jp	m,L00219
L00220:
; |>>> fError=2;
	ld	l,2
	ld	a,l
	ld	(_fError),a		; fError
; |>>> else {
	jp	E00219
L00219:
; |>>> *l=(unsigned long)inp(i);
	push	hl
	ld	e,(iy-6)		; i
	push	de
	call	_inp
	pop	af
	ld	e,l
	pop	hl
	ld	d,0
	ld	c,d
	ld	b,d
	ld	(ix+0),e
	ld	(ix+1),d
	ld	(ix+2),c
	ld	(ix+3),b
; |>>> RetVal=1;
	ld	(iy-15),1		; RetVal
E00219:
; |>>> break;
	jp	J00214
; |>>> case 16:                   `
J00214_10:
; |>>> l1=GetValue(1);
	ld	l,1
	push	hl
	call	_GetValue
	pop	af
	ld	(iy-14),l
	ld	(iy-13),h
	ld	(iy-12),e
	ld	(iy-11),d		; l1
; |>>> *l=*(((int *)&l1)+1);
	push	iy
	pop	de
	ld	a,e
	sub	14
	ld	e,a
	ld	a,d
	sbc	a,0
	ld	d,a		; addr. l1
	inc	de
	inc	de
	ld	a,(de)
	inc	de
	push	af
	ld	a,(de)
	ld	d,a
	pop	af
	ld	e,a
	ld	a,d
	sla	a
	sbc	a,a
	ld	c,a
	ld	b,c
	ld	(ix+0),e
	ld	(ix+1),d
	ld	(ix+2),c
	ld	(ix+3),b
; |>>> RetVal=1;
	ld	(iy-15),1		; RetVal
; |>>> break;
	jp	J00214
; |>>> case 17:                   |
J00214_11:
; |>>> break;
	jp	J00214
; |>>> case 18:                   |
J00214_12:
; |>>> l1=GetValue(1);
	ld	l,1
	push	hl
	call	_GetValue
	pop	af
	ld	(iy-14),l
	ld	(iy-13),h
	ld	(iy-12),e
	ld	(iy-11),d		; l1
; |>>> i=*(((int *)&l1)+1);
	push	iy
	pop	hl
	ld	a,l
	sub	14
	ld	l,a
	ld	a,h
	sbc	a,0
	ld	h,a		; addr. l1
	inc	hl
	inc	hl
	ld	a,(hl)
	inc	hl
	ld	h,(hl)
	ld	l,a
	ld	(iy-6),l
	ld	(iy-5),h		; i
; |>>> p=((char *)l1)+i;          `
	ld	l,(iy-14)
	ld	h,(iy-13)		; l1
	ld	a,l
	add	a,(iy-6)
	ld	l,a
	ld	a,h
	adc	a,(iy-5)
	ld	h,a
	ld	(iy-2),l
	ld	(iy-1),h		; p
; |>>> ch=*p;
	ld	l,(iy-2)
	ld	h,(iy-1)		; p
	ld	l,(hl)
	ld	(iy-3),l		; ch
; |>>> *p=0;
	ld	l,(iy-2)
	ld	h,(iy-1)		; p
	ld	(hl),0
; |>>> *l=atol((char *)l1);
	push	hl
	ld	e,(iy-14)
	ld	d,(iy-13)		; l1
	push	de
	call	_atol
	pop	af
	ld	c,e
	ld	b,d
	ld	d,h
	ld	e,l
	pop	hl
	ld	(ix+0),e
	ld	(ix+1),d
	ld	(ix+2),c
	ld	(ix+3),b
; |>>> *p=ch;
	ld	l,(iy-2)
	ld	h,(iy-1)		; p
	ld	e,(iy-3)		; ch
	ld	(hl),e
; |>>> RetVal=0;
	ld	(iy-15),0		; RetVal
; |>>> break;
	jp	J00214
; |>>> case 19:                   M
J00214_13:
; |>>> i=GetValue(0);
	xor	a
	ld	l,a
	push	hl
	call	_GetValue
	pop	af
	ld	(iy-6),l
	ld	(iy-5),h		; i
; |>>> p=AllocaString(1);
	ld	hl,1
	push	hl
	call	_AllocaString
	pop	af
	ld	(iy-2),l
	ld	(iy-1),h		; p
; |>>> if(p) {
	ld	a,(iy-2)
	or	(iy-1)		; p
	jp	z,L00221
; |>>> *(char **)l=p;
	push	ix
	pop	hl		; l
	ld	e,(iy-2)
	ld	d,(iy-1)		; p
	ld	(hl),e
	inc	hl
	ld	(hl),d
; |>>> *(((int *)l)+1)=1;
	push	ix
	pop	hl		; l
	inc	hl
	inc	hl
	ld	(hl),1
	inc	hl
	ld	(hl),0
; |>>> *p=i;
	ld	l,(iy-2)
	ld	h,(iy-1)		; p
	ld	e,(iy-6)		; i
	ld	(hl),e
; |>>> RetVal=2;
	ld	(iy-15),2		; RetVal
L00221:
; |>>> break;
	jp	J00214
; |>>> case 20:                   |
J00214_14:
; |>>> l1=GetValue(1);
	ld	l,1
	push	hl
	call	_GetValue
	pop	af
	ld	(iy-14),l
	ld	(iy-13),h
	ld	(iy-12),e
	ld	(iy-11),d		; l1
; |>>> *l=*(unsigned char *)l1;
	ld	e,(iy-14)
	ld	d,(iy-13)		; l1
	ld	a,(de)
	ld	e,a
	ld	a,e
	sla	a
	sbc	a,a
	ld	d,a
	ld	c,d
	ld	b,d
	ld	(ix+0),e
	ld	(ix+1),d
	ld	(ix+2),c
	ld	(ix+3),b
; |>>> RetVal=1;
	ld	(iy-15),1		; RetVal
; |>>> break;
	jp	J00214
; |>>> case 21:                   |
J00214_15:
; |>>> l1=GetValue(1);
	ld	l,1
	push	hl
	call	_GetValue
	pop	af
	ld	(iy-14),l
	ld	(iy-13),h
	ld	(iy-12),e
	ld	(iy-11),d		; l1
; |>>> if(!DoCheck(',')) {
	ld	l,44
	push	hl
	call	_DoCheck
	pop	af
	ld	e,l
	ld	a,l
	or	a
	jp	nz,L00222
; |>>> i=GetValue(0);
	xor	a
	ld	l,a
	push	hl
	call	_GetValue
	pop	af
	ld	(iy-6),l
	ld	(iy-5),h		; i
; |>>> i--;
	ld	a,(iy-6)
	dec	(iy-6)
	or	a
	jr	nz,$+5
	dec	(iy-5)
; |>>> j=*(((int *)&l1)+1);
	push	iy
	pop	hl
	ld	a,l
	sub	14
	ld	l,a
	ld	a,h
	sbc	a,0
	ld	h,a		; addr. l1
	inc	hl
	inc	hl
	ld	a,(hl)
	inc	hl
	ld	h,(hl)
	ld	l,a
	ld	(iy-8),l
	ld	(iy-7),h		; j
; |>>> if(i <= j) {
	ld	l,(iy-8)
	ld	h,(iy-7)		; j
	ld	a,(iy-6)
	scf
	sbc	a,l
	ld	a,(iy-5)
	sbc	a,h
	jp	p,L00223
; |>>> *(int *)l=(*(int *)&l1)+i;|
	push	ix
	pop	hl		; l
	push	iy
	pop	de
	ld	a,e
	sub	14
	ld	e,a
	ld	a,d
	sbc	a,0
	ld	d,a		; addr. l1
	ld	a,(de)
	inc	de
	push	af
	ld	a,(de)
	ld	d,a
	pop	af
	ld	e,a
	ld	a,e
	add	a,(iy-6)
	ld	e,a
	ld	a,d
	adc	a,(iy-5)
	ld	d,a
	ld	(hl),e
	inc	hl
	ld	(hl),d
; |>>> SkipSpaces();
	call	_SkipSpaces
; |>>> if(*TextP == ',') {
	ld	hl,(_TextP)		; TextP
	ld	l,(hl)
	ld	a,l
	cp	44
	jp	nz,L00224
; |>>> TextP++;
	ld	hl,(_TextP)
	inc	hl
	ld	(_TextP),hl
; |>>> i1=GetValue(0);
	xor	a
	ld	l,a
	push	hl
	call	_GetValue
	pop	af
	ld	(iy-10),l
	ld	(iy-9),h		; i1
; |>>> if(i1 <= (j-i)) {
	ld	l,(iy-8)
	ld	h,(iy-7)		; j
	ld	a,l
	sub	(iy-6)
	ld	l,a
	ld	a,h
	sbc	a,(iy-5)
	ld	h,a
	ld	a,(iy-10)
	scf
	sbc	a,l
	ld	a,(iy-9)
	sbc	a,h
	jp	p,L00225
; |>>> *(((int *)l)+1)=i1;
	push	ix
	pop	hl		; l
	inc	hl
	inc	hl
	ld	e,(iy-10)
	ld	d,(iy-9)		; i1
	ld	(hl),e
	inc	hl
	ld	(hl),d
L00225:
; |>>> else {
	jp	E00224
L00224:
; |>>> *(((int *)l)+1)=*(((int *)&|
	push	ix
	pop	hl		; l
	inc	hl
	inc	hl
	push	iy
	pop	de
	ld	a,e
	sub	14
	ld	e,a
	ld	a,d
	sbc	a,0
	ld	d,a		; addr. l1
	inc	de
	inc	de
	ld	a,(de)
	inc	de
	push	af
	ld	a,(de)
	ld	d,a
	pop	af
	ld	e,a
	ld	a,e
	sub	(iy-6)
	ld	e,a
	ld	a,d
	sbc	a,(iy-5)
	ld	d,a
	ld	(hl),e
	inc	hl
	ld	(hl),d
E00224:
; |>>> RetVal=2;
	ld	(iy-15),2		; RetVal
; |>>> else
	jp	E00223
L00223:
; |>>> fError=2;
	ld	l,2
	ld	a,l
	ld	(_fError),a		; fError
E00223:
L00222:
; |>>> break;
	jp	J00214
; |>>> case 24:                   |
J00214_18:
; |>>> i=GetValue(0);
	xor	a
	ld	l,a
	push	hl
	call	_GetValue
	pop	af
	ld	(iy-6),l
	ld	(iy-5),h		; i
; |>>> i1=i & 7;
	ld	l,(iy-6)
	ld	h,(iy-5)		; i
	ld	a,l
	and	7
	ld	l,a
	ld	a,h
	and	0
	ld	h,a
	ld	(iy-10),l
	ld	(iy-9),h		; i1
; |>>> i >>= 3;
	sra	(iy-6)
	rr	(iy-6)
	sra	(iy-5)
	rr	(iy-6)
	sra	(iy-4)
	rr	(iy-6)
; |>>> i=inp(i);
	ld	l,(iy-6)		; i
	push	hl
	call	_inp
	pop	af
	ld	a,l
	sla	a
	sbc	a,a
	ld	h,a
	ld	(iy-6),l
	ld	(iy-5),h		; i
; |>>> i1=BitTable[i1] ? 0 : 1;
	ld	hl,_BitTable		; addr. BitTable
	ld	e,(iy-10)
	ld	d,(iy-9)		; i1
	add	hl,de
	ld	a,(hl)
	or	a
	jp	z,L00226
	ld	hl,0
	jr	L00226_
L00226:
	ld	hl,1
L00226_:
	ld	(iy-10),l
	ld	(iy-9),h		; i1
; |>>> *l=(i & i1) ? 1 : 0;
	ld	e,(iy-6)
	ld	d,(iy-5)		; i
	ld	a,e
	and	(iy-10)
	ld	e,a
	ld	a,d
	and	(iy-9)
	ld	d,a
	ld	a,e
	or	d
	jp	z,L00227
	ld	de,1
	jr	L00227_
L00227:
	ld	de,0
L00227_:
	ld	a,d
	sla	a
	sbc	a,a
	ld	c,a
	ld	b,c
	ld	(ix+0),e
	ld	(ix+1),d
	ld	(ix+2),c
	ld	(ix+3),b
; |>>> RetVal=1;
	ld	(iy-15),1		; RetVal
; |>>> break;
	jp	J00214
J00214:
; |>>> DoCheck(')');
	ld	l,41
	push	hl
	call	_DoCheck
	pop	af
; |>>> return RetVal;
	ld	l,(iy-15)		; RetVal
	jp	R00212
; |>>> else if((_ctype[ch] & (0x1 }
	jp	E00213
L00213:
; |>>> if((_ctype[ch] & (0x1 | 0x2|
	ld	hl,__ctype		; addr. _ctype
	ld	e,(iy-3)
	ld	d,0		; ch
	add	hl,de
	ld	l,(hl)
	ld	a,l
	and	3
	ld	l,a
	ld	a,l
	or	a
	jp	z,L00228
; |>>> if(( ((_ctype[ch] & 0x2 )) |
	ld	hl,__ctype		; addr. _ctype
	ld	e,(iy-3)
	ld	d,0		; ch
	add	hl,de
	ld	l,(hl)
	ld	a,l
	and	2
	ld	l,a
	ld	a,l
	or	a
	jp	z,L00230
	ld	l,(iy-3)		; ch
	ld	a,l
	sub	65
	ld	l,a
	ld	a,l
	add	a,97
	ld	l,a
	jr	L00230_
L00230:
	ld	l,(iy-3)		; ch
L00230_:
	ld	a,l
	cp	84
	jp	nz,L00229
	ld	de,(_TextP)		; TextP
	inc	de
	ld	hl,__ctype		; addr. _ctype
	ld	a,(de)
	ld	e,a
	ld	d,0
	add	hl,de
	ld	l,(hl)
	ld	a,l
	and	2
	ld	l,a
	ld	a,l
	or	a
	jp	z,L00231
	ld	hl,(_TextP)		; TextP
	inc	hl
	ld	l,(hl)
	ld	a,l
	sub	65
	ld	l,a
	ld	a,l
	add	a,97
	ld	l,a
	jr	L00231_
L00231:
	ld	hl,(_TextP)		; TextP
	inc	hl
	ld	l,(hl)
L00231_:
	ld	a,l
	cp	73
	jp	nz,L00229
; |>>> TextP+=2;
	ld	hl,(_TextP)		; TextP
	inc	hl
	inc	hl
	ld	(_TextP),hl		; TextP
; |>>> *l=clock();
	push	hl
	call	_clock
	ld	d,h
	ld	e,l
	pop	hl
	ld	a,d
	sla	a
	sbc	a,a
	ld	c,a
	ld	b,c
	ld	(ix+0),e
	ld	(ix+1),d
	ld	(ix+2),c
	ld	(ix+3),b
; |>>> return 0;
	xor	a
	ld	l,a
	jp	R00212
; |>>> else {
	jp	E00229
L00229:
; |>>> p=HandleVar(0,&Fl);
	push	iy
	pop	hl
	dec	hl
	dec	hl
	dec	hl
	dec	hl		; addr. Fl
	push	hl
	xor	a
	ld	l,a
	push	hl
	call	_HandleVar
	pop	af
	pop	af
	ld	(iy-2),l
	ld	(iy-1),h		; p
; |>>> if(!fError) {
	ld	a,(_fError)		; fError
	or	a
	jp	nz,L00232
; |>>> if(Fl & 1) {
	bit	0,(iy-4)
	jp	z,L00233
; |>>> *l=(long)(*(int *)p);
	ld	e,(iy-2)
	ld	d,(iy-1)		; p
	ld	a,(de)
	inc	de
	push	af
	ld	a,(de)
	ld	d,a
	pop	af
	ld	e,a
	ld	a,d
	sla	a
	sbc	a,a
	ld	c,a
	ld	b,c
	ld	(ix+0),e
	ld	(ix+1),d
	ld	(ix+2),c
	ld	(ix+3),b
; |>>> else {
	jp	E00233
L00233:
; |>>> *l=*(long *)p;
	ld	e,(iy-2)
	ld	d,(iy-1)		; p
	ld	a,(de)
	push	af
	inc	de
	ld	a,(de)
	push	af
	inc	de
	ld	a,(de)
	ld	c,a
	inc	de
	ld	a,(de)
	ld	b,a
	pop	af
	ld	d,a
	pop	af
	ld	e,a
	ld	(ix+0),e
	ld	(ix+1),d
	ld	(ix+2),c
	ld	(ix+3),b
E00233:
; |>>> return Fl;
	ld	l,(iy-4)		; Fl
	jp	R00212
L00232:
E00229:
; |>>> else {
	jp	E00228
L00228:
; |>>> switch(ch) {
	ld	l,(iy-3)		; ch
	ld	a,l
	ld	hl,J00234_T-1
	ld	bc,9
	cpdr
	ld	a,b
	or	c
	jp	z,J00234
	ld	hl,J00234_T-2
	add	hl,bc
	add	hl,bc
	ld	a,(hl)
	inc	hl
	ld	h,(hl)
	ld	l,a
	jp	(hl)
J00234_N:
db		38
db		34
db		92
db		36
db		33
db		35
db		39
db		32
J00234_T:
dw	J00234_26
dw	J00234_22
dw	J00234_5c
dw	J00234_24
dw	J00234_21
dw	J00234_23
dw	J00234_27
dw	J00234_20
; |>>> case '&':
J00234_26:
; |>>> TextP+=2;                  |
	ld	hl,(_TextP)		; TextP
	inc	hl
	inc	hl
	ld	(_TextP),hl		; TextP
; |>>> *l=myXtoi();
	push	hl
	call	_myXtoi
	ld	d,h
	ld	e,l
	pop	hl
	ld	a,d
	sla	a
	sbc	a,a
	ld	c,a
	ld	b,c
	ld	(ix+0),e
	ld	(ix+1),d
	ld	(ix+2),c
	ld	(ix+3),b
; |>>> return 1;
	ld	l,1
	jp	R00212
; |>>> break;
	jp	J00234
; |>>> case '\"':
J00234_22:
; |>>> *(char **)l=++TextP;
	push	ix
	pop	hl		; l
	ld	de,(_TextP)
	inc	de
	ld	(_TextP),de
	ld	(hl),e
	inc	hl
	ld	(hl),d
; |>>> i=0;
	ld	(iy-6),0
	ld	(iy-5),0		; i
; |>>> while(*TextP != '\"' && *Te|
J00235_:
	ld	hl,(_TextP)		; TextP
	ld	l,(hl)
	ld	a,l
	cp	34
	jp	z,J00235
	ld	hl,(_TextP)		; TextP
	ld	a,(hl)
	or	a
	jp	z,J00235
; |>>> i++;
	inc	(iy-6)
	jr	nz,$+5
	inc	(iy-5)
; |>>> TextP++;
	ld	hl,(_TextP)
	inc	hl
	ld	(_TextP),hl
	jp 	J00235_
J00235:
; |>>> *(((int *)l)+1)=i;
	push	ix
	pop	hl		; l
	inc	hl
	inc	hl
	ld	e,(iy-6)
	ld	d,(iy-5)		; i
	ld	(hl),e
	inc	hl
	ld	(hl),d
; |>>> if(*TextP)
	ld	hl,(_TextP)		; TextP
	ld	a,(hl)
	or	a
	jp	z,L00236
; |>>> TextP++;
	ld	hl,(_TextP)
	inc	hl
	ld	(_TextP),hl
L00236:
; |>>> if(DirectMode) {
	ld	a,(_DirectMode)		; DirectMode
	or	a
	jp	z,L00237
; |>>> p=AllocaString(i);
	ld	l,(iy-6)
	ld	h,(iy-5)		; i
	push	hl
	call	_AllocaString
	pop	af
	ld	(iy-2),l
	ld	(iy-1),h		; p
; |>>> if(p) {
	ld	a,(iy-2)
	or	(iy-1)		; p
	jp	z,L00238
; |>>> memmove(p,*(char **)l,i);
	ld	l,(iy-6)
	ld	h,(iy-5)		; i
	push	hl
	push	ix
	pop	hl		; l
	ld	a,(hl)
	inc	hl
	ld	h,(hl)
	ld	l,a
	push	hl
	ld	l,(iy-2)
	ld	h,(iy-1)		; p
	push	hl
	call	_memmove
	pop	af
	pop	af
	pop	af
; |>>> *(char **)l=p;
	push	ix
	pop	hl		; l
	ld	e,(iy-2)
	ld	d,(iy-1)		; p
	ld	(hl),e
	inc	hl
	ld	(hl),d
L00238:
L00237:
; |>>> return 2;
	ld	l,2
	jp	R00212
; |>>> break;
	jp	J00234
; |>>> case '\\':
J00234_5c:
; |>>> case '$':
J00234_24:
; |>>> case '!':
J00234_21:
; |>>> case '#':
J00234_23:
; |>>> case '\'':
J00234_27:
; |>>> fError=1;
	ld	l,1
	ld	a,l
	ld	(_fError),a		; fError
; |>>> break;
	jp	J00234
; |>>> case ' ':
J00234_20:
; |>>> TextP++;
	ld	hl,(_TextP)
	inc	hl
	ld	(_TextP),hl
; |>>> goto rifo;
	jp	rifo_GetAritmElem
; |>>> break;
	jp	J00234
J00234:
E00228:
E00213:
E00208:
; |>>> return -1;
	ld	l,255
	jp	R00212
R00212:
	pop	ix
	ld	sp,iy
	pop	iy
	ret
_GetAritmElem	endp
; --------------------------------}

; |--- char RecursEval(char Pty, r`

public	_RecursEval
_RecursEval	proc
; temp = -24
	push	iy
	ld	iy,-24
	add	iy,sp
	ld	sp,iy
	ld	iy,24
	add	iy,sp
	push	ix
; Pty = 4
; register ix = l1
	ld	l,(iy+6)
	ld	h,(iy+7)
	push	hl
	pop	ix
; f1 = 8
; |--- long l2;
; l2 = -4
; |--- char f2;
; f2 = -5
; |--- char ch;
; ch = -6
; |--- char Go=0,InBrack=0,Times=0`
; Go = -7
	ld	(iy-7),0		; Go
; InBrack = -8
	ld	(iy-8),0		; InBrack
; Times = -9
	ld	(iy-9),0		; Times
; |--- char *p,*p1;
; p = -12
; p1 = -14
; |--- int i,i1,j;
; i = -16
; i1 = -18
; j = -20
; |>>> do {
J00239:
; |>>> ch=*TextP;
	ld	hl,(_TextP)		; TextP
	ld	l,(hl)
	ld	(iy-6),l		; ch
; |>>> switch(ch) {
	ld	l,(iy-6)		; ch
	ld	a,l
	ld	hl,J00240_T-1
	ld	bc,25
	cpdr
	ld	a,b
	or	c
	jp	z,J00240_
	ld	hl,J00240_T-2
	add	hl,bc
	add	hl,bc
	ld	a,(hl)
	inc	hl
	ld	h,(hl)
	ld	l,a
	jp	(hl)
J00240_N:
db		40
db		41
db		43
db		45
db		42
db		47
db		94
db		37
db		60
db		61
db		62
db		192
db		193
db		32
db		0
db		58
db		59
db		44
db		145
db		144
db		140
db		141
db		137
db		138
J00240_T:
dw	J00240_28
dw	J00240_29
dw	J00240_2b
dw	J00240_2d
dw	J00240_2a
dw	J00240_2f
dw	J00240_5e
dw	J00240_25
dw	J00240_3c
dw	J00240_3d
dw	J00240_3e
dw	J00240_c0
dw	J00240_c1
dw	J00240_20
dw	J00240_0
dw	J00240_3a
dw	J00240_3b
dw	J00240_2c
dw	J00240_91
dw	J00240_90
dw	J00240_8c
dw	J00240_8d
dw	J00240_89
dw	J00240_8a
; |>>> case '(':
J00240_28:
; |>>> TextP++;
	ld	hl,(_TextP)
	inc	hl
	ld	(_TextP),hl
; |>>> InBrack++;
	inc	(iy-8)
; |>>> break;
	jp	J00240
; |>>> case ')':
J00240_29:
; |>>> if(InBrack) {
	ld	a,(iy-8)		; InBrack
	or	a
	jp	z,L00241
; |>>> TextP++;
	ld	hl,(_TextP)
	inc	hl
	ld	(_TextP),hl
; |>>> InBrack--;
	dec	(iy-8)
; |>>> else
	jp	E00241
L00241:
; |>>> Go=1;
	ld	(iy-7),1		; Go
E00241:
; |>>> break;
	jp	J00240
; |>>> case '+':
J00240_2b:
; |>>> case '-':
J00240_2d:
; |>>> if(Times) {
	ld	a,(iy-9)		; Times
	or	a
	jp	z,L00242
; |>>> if(Pty >= 5) {
	ld	a,(iy+4)
	cp	5
	jp	m,L00243
; |>>> TextP++;
	ld	hl,(_TextP)
	inc	hl
	ld	(_TextP),hl
; |>>> RecursEval(4,&l2,&f2);
	push	iy
	pop	hl
	ld	a,l
	sub	5
	ld	l,a
	ld	a,h
	sbc	a,0
	ld	h,a		; addr. f2
	push	hl
	push	iy
	pop	hl
	dec	hl
	dec	hl
	dec	hl
	dec	hl		; addr. l2
	push	hl
	ld	l,4
	push	hl
	call	_RecursEval
	pop	af
	pop	af
	pop	af
; |>>> if(*f1 & 2) {
	ld	l,(iy+8)
	ld	h,(iy+9)		; f1
	ld	l,(hl)
	ld	a,l
	and	2
	ld	l,a
	ld	a,l
	or	a
	jp	z,L00244
; |>>> if(f2 & 2) {
	bit	1,(iy-5)
	jp	z,L00245
; |>>> i=*(((int *)l1)+1);
	push	ix
	pop	hl		; l1
	inc	hl
	inc	hl
	ld	a,(hl)
	inc	hl
	ld	h,(hl)
	ld	l,a
	ld	(iy-16),l
	ld	(iy-15),h		; i
; |>>> i1=*(((int *)&l2)+1);
	push	iy
	pop	hl
	dec	hl
	dec	hl
	dec	hl
	dec	hl		; addr. l2
	inc	hl
	inc	hl
	ld	a,(hl)
	inc	hl
	ld	h,(hl)
	ld	l,a
	ld	(iy-18),l
	ld	(iy-17),h		; i1
; |>>> p=AllocaString(i+i1);
	ld	l,(iy-16)
	ld	h,(iy-15)		; i
	ld	a,l
	add	a,(iy-18)
	ld	l,a
	ld	a,h
	adc	a,(iy-17)
	ld	h,a
	push	hl
	call	_AllocaString
	pop	af
	ld	(iy-12),l
	ld	(iy-11),h		; p
; |>>> if(p) {
	ld	a,(iy-12)
	or	(iy-11)		; p
	jp	z,L00246
; |>>> memmove(p,(char *)*(int *)l|
	ld	l,(iy-16)
	ld	h,(iy-15)		; i
	push	hl
	push	ix
	pop	hl		; l1
	ld	a,(hl)
	inc	hl
	ld	h,(hl)
	ld	l,a
	push	hl
	ld	l,(iy-12)
	ld	h,(iy-11)		; p
	push	hl
	call	_memmove
	pop	af
	pop	af
	pop	af
; |>>> memmove(p+i,(char *)*((int |
	ld	l,(iy-18)
	ld	h,(iy-17)		; i1
	push	hl
	push	iy
	pop	hl
	dec	hl
	dec	hl
	dec	hl
	dec	hl		; addr. l2
	ld	a,(hl)
	inc	hl
	ld	h,(hl)
	ld	l,a
	push	hl
	ld	l,(iy-12)
	ld	h,(iy-11)		; p
	ld	a,l
	add	a,(iy-16)
	ld	l,a
	ld	a,h
	adc	a,(iy-15)
	ld	h,a
	push	hl
	call	_memmove
	pop	af
	pop	af
	pop	af
; |>>> *(char **)l1=p;
	push	ix
	pop	hl		; l1
	ld	e,(iy-12)
	ld	d,(iy-11)		; p
	ld	(hl),e
	inc	hl
	ld	(hl),d
; |>>> *(((int *)l1)+1)=i+i1;
	push	ix
	pop	hl		; l1
	inc	hl
	inc	hl
	ld	e,(iy-16)
	ld	d,(iy-15)		; i
	ld	a,e
	add	a,(iy-18)
	ld	e,a
	ld	a,d
	adc	a,(iy-17)
	ld	d,a
	ld	(hl),e
	inc	hl
	ld	(hl),d
L00246:
; |>>> else
	jp	E00245
L00245:
; |>>> fError=4;
	ld	l,4
	ld	a,l
	ld	(_fError),a		; fError
E00245:
; |>>> else {
	jp	E00244
L00244:
; |>>> if(ch=='+')
	ld	a,(iy-6)
	cp	43
	jp	nz,L00247
; |>>> *l1+=l2;
	ld	a,(ix+0)
	add	a,(iy-4)
	ld	(ix+0),a
	inc	ix
	ld	a,(ix+0)
	adc	a,(iy-3)
	ld	(ix+0),a
	inc	ix
	ld	a,(ix+0)
	adc	a,(iy-2)
	ld	(ix+0),a
	inc	ix
	ld	a,(ix+0)
	adc	a,(iy-1)
	ld	(ix+0),a
	jp	E00247
L00247:
; |>>> else
; |>>> *l1-=l2;
	ld	a,(ix+0)
	sub	(iy-4)
	ld	(ix+0),a
	inc	ix
	ld	a,(ix+0)
	sbc	a,(iy-3)
	ld	(ix+0),a
	inc	ix
	ld	a,(ix+0)
	sbc	a,(iy-2)
	ld	(ix+0),a
	inc	ix
	ld	a,(ix+0)
	sbc	a,(iy-1)
	ld	(ix+0),a
E00247:
E00244:
; |>>> else
	jp	E00243
L00243:
; |>>> Go=1;
	ld	(iy-7),1		; Go
E00243:
; |>>> else {
	jp	E00242
L00242:
; |>>> if(Pty >= 3) {
	ld	a,(iy+4)
	cp	3
	jp	m,L00248
; |>>> TextP++;
	ld	hl,(_TextP)
	inc	hl
	ld	(_TextP),hl
; |>>> RecursEval(2,l1,f1);
	ld	l,(iy+8)
	ld	h,(iy+9)		; f1
	push	hl
	push	ix
	ld	l,2
	push	hl
	call	_RecursEval
	pop	af
	pop	af
	pop	af
; |>>> if(ch=='-')
	ld	a,(iy-6)
	cp	45
	jp	nz,L00249
; |>>> *l1=-*l1;
	ld	e,(ix+0)
	ld	d,(ix+1)
	ld	c,(ix+2)
	ld	b,(ix+3)
	ld	a,e
	cpl
	ld	e,a
	ld	a,d
	cpl
	ld	d,a
	ld	a,c
	cpl
	ld	c,a
	ld	a,b
	cpl
	ld	b,a
	inc	de
	ld	a,e
	or	d
	jr	nz,$+3
	inc	bc
	ld	(ix+0),e
	ld	(ix+1),d
	ld	(ix+2),c
	ld	(ix+3),b
L00249:
; |>>> if(*f1 & 2)
	ld	l,(iy+8)
	ld	h,(iy+9)		; f1
	ld	l,(hl)
	ld	a,l
	and	2
	ld	l,a
	ld	a,l
	or	a
	jp	z,L00250
; |>>> fError=4;
	ld	l,4
	ld	a,l
	ld	(_fError),a		; fError
L00250:
; |>>> else
	jp	E00248
L00248:
; |>>> Go=1;
	ld	(iy-7),1		; Go
E00248:
E00242:
; |>>> break;
	jp	J00240
; |>>> case '*':
J00240_2a:
; |>>> case '/':
J00240_2f:
; |>>> case '^':
J00240_5e:
; |>>> case '%':
J00240_25:
; |>>> if(Pty >= 4) {
	ld	a,(iy+4)
	cp	4
	jp	m,L00251
; |>>> TextP++;
	ld	hl,(_TextP)
	inc	hl
	ld	(_TextP),hl
; |>>> RecursEval(3,&l2,&f2);
	push	iy
	pop	hl
	ld	a,l
	sub	5
	ld	l,a
	ld	a,h
	sbc	a,0
	ld	h,a		; addr. f2
	push	hl
	push	iy
	pop	hl
	dec	hl
	dec	hl
	dec	hl
	dec	hl		; addr. l2
	push	hl
	ld	l,3
	push	hl
	call	_RecursEval
	pop	af
	pop	af
	pop	af
; |>>> if((*f1 & 2) || (f2 & 2)) {|
	ld	l,(iy+8)
	ld	h,(iy+9)		; f1
	ld	l,(hl)
	ld	a,l
	and	2
	ld	l,a
	ld	a,l
	or	a
	jp	nz,L00253
	bit	1,(iy-5)
	jp	z,L00252
L00253:
; |>>> fError=4;
	ld	l,4
	ld	a,l
	ld	(_fError),a		; fError
; |>>> else {
	jp	E00252
L00252:
; |>>> switch(ch) {
	ld	l,(iy-6)		; ch
	ld	a,l
	cp	42
	jp	z,J00254_2a
	cp	47
	jp	z,J00254_2f
	cp	94
	jp	z,J00254_5e
	cp	37
	jp	z,J00254_25
	jp	J00254
; |>>> case '*':
J00254_2a:
; |>>> *l1 = *l1 * l2;
	ld	e,(ix+0)
	ld	d,(ix+1)
	ld	c,(ix+2)
	ld	b,(ix+3)
	push	de
	push	bc
	ld	e,(iy-4)
	ld	d,(iy-3)
	ld	c,(iy-2)
	ld	b,(iy-1)		; l2
	ld	(iy-24),e
	ld	(iy-23),d
	ld	(iy-22),c
	ld	(iy-21),b
	pop	bc
	pop	de
	push	bc
	push	de
	ld	e,(iy-22)
	ld	d,(iy-21)
	push	de
	ld	e,(iy-24)
	ld	d,(iy-23)
	push	de
	call	__lmul
	pop	af
	pop	af
	pop	af
	pop	af
	ld	e,h
	ld	d,l
	ld	c,h
	ld	b,l
	pop	hl
	ld	(ix+0),e
	ld	(ix+1),d
	ld	(ix+2),c
	ld	(ix+3),b
; |>>> break;
	jp	J00254
; |>>> case '/':
J00254_2f:
; |>>> *l1 = *l1 / l2;
	ld	e,(ix+0)
	ld	d,(ix+1)
	ld	c,(ix+2)
	ld	b,(ix+3)
	push	de
	push	bc
	ld	e,(iy-4)
	ld	d,(iy-3)
	ld	c,(iy-2)
	ld	b,(iy-1)		; l2
	ld	(iy-24),e
	ld	(iy-23),d
	ld	(iy-22),c
	ld	(iy-21),b
	pop	bc
	pop	de
	push	bc
	push	de
	ld	e,(iy-22)
	ld	d,(iy-21)
	push	de
	ld	e,(iy-24)
	ld	d,(iy-23)
	push	de
	call	__ldiv
	pop	af
	pop	af
	pop	af
	pop	af
	ld	(ix+0),e
	ld	(ix+1),d
	ld	(ix+2),c
	ld	(ix+3),b
; |>>> break;
	jp	J00254
; |>>> case '^':
J00254_5e:
; |>>> *l1=pow(*l1,l2);
	push	hl
	ld	e,(iy-4)
	ld	d,(iy-3)		; l2
	push	bc
	push	de
	ld	e,(ix+0)
	ld	e,(ix+1)
	push	bc
	push	de
	call	_pow
	pop	af
	pop	af
	pop	af
	pop	af
	ld	d,h
	ld	e,l
	pop	hl
	ld	a,d
	sla	a
	sbc	a,a
	ld	c,a
	ld	b,c
	ld	(ix+0),e
	ld	(ix+1),d
	ld	(ix+2),c
	ld	(ix+3),b
; |>>> break;
	jp	J00254
; |>>> case '%':
J00254_25:
; |>>> *l1 = *l1 % l2;
	ld	e,(ix+0)
	ld	d,(ix+1)
	ld	c,(ix+2)
	ld	b,(ix+3)
	push	de
	push	bc
	ld	e,(iy-4)
	ld	d,(iy-3)
	ld	c,(iy-2)
	ld	b,(iy-1)		; l2
	ld	(iy-24),e
	ld	(iy-23),d
	ld	(iy-22),c
	ld	(iy-21),b
	pop	bc
	pop	de
	push	bc
	push	de
	ld	e,(iy-22)
	ld	d,(iy-21)
	push	de
	ld	e,(iy-24)
	ld	d,(iy-23)
	push	de
	call	__ldiv
	pop	af
	pop	af
	pop	af
	pop	af
	ld	h,d
	ld	l,e
	ld	(ix+0),e
	ld	(ix+1),d
	ld	(ix+2),c
	ld	(ix+3),b
; |>>> break;
	jp	J00254
J00254:
E00252:
; |>>> else
	jp	E00251
L00251:
; |>>> Go=1;
	ld	(iy-7),1		; Go
E00251:
; |>>> break;
	jp	J00240
; |>>> case '<':
J00240_3c:
; |>>> case '=':
J00240_3d:
; |>>> case '>':
J00240_3e:
; |>>> i=0;
	ld	(iy-16),0
	ld	(iy-15),0		; i
; |>>> if(Pty >= 6) {
	ld	a,(iy+4)
	cp	6
	jp	m,L00255
; |>>> TextP++;
	ld	hl,(_TextP)
	inc	hl
	ld	(_TextP),hl
; |>>> if(*TextP == '=') {
	ld	hl,(_TextP)		; TextP
	ld	l,(hl)
	ld	a,l
	cp	61
	jp	nz,L00256
; |>>> i=1;
	ld	(iy-16),1
	ld	(iy-15),0		; i
; |>>> TextP++;
	ld	hl,(_TextP)
	inc	hl
	ld	(_TextP),hl
; |>>> else {
	jp	E00256
L00256:
; |>>> if(*TextP == '>') {
	ld	hl,(_TextP)		; TextP
	ld	l,(hl)
	ld	a,l
	cp	62
	jp	nz,L00257
; |>>> i=-1;
	ld	(iy-16),255
	ld	(iy-15),255		; i
; |>>> TextP++;
	ld	hl,(_TextP)
	inc	hl
	ld	(_TextP),hl
L00257:
E00256:
; |>>> RecursEval(5,&l2,&f2);
	push	iy
	pop	hl
	ld	a,l
	sub	5
	ld	l,a
	ld	a,h
	sbc	a,0
	ld	h,a		; addr. f2
	push	hl
	push	iy
	pop	hl
	dec	hl
	dec	hl
	dec	hl
	dec	hl		; addr. l2
	push	hl
	ld	l,5
	push	hl
	call	_RecursEval
	pop	af
	pop	af
	pop	af
; |>>> if(*f1 & 2) {
	ld	l,(iy+8)
	ld	h,(iy+9)		; f1
	ld	l,(hl)
	ld	a,l
	and	2
	ld	l,a
	ld	a,l
	or	a
	jp	z,L00258
; |>>> if(f2 & 2) {
	bit	1,(iy-5)
	jp	z,L00259
; |>>> p=*(char **)l1;
	push	ix
	pop	hl		; l1
	ld	a,(hl)
	inc	hl
	ld	h,(hl)
	ld	l,a
	ld	(iy-12),l
	ld	(iy-11),h		; p
; |>>> p1=*((char **)&l2);
	push	iy
	pop	hl
	dec	hl
	dec	hl
	dec	hl
	dec	hl		; addr. l2
	ld	a,(hl)
	inc	hl
	ld	h,(hl)
	ld	l,a
	ld	(iy-14),l
	ld	(iy-13),h		; p1
; |>>> i=*(((int *)l1)+1);
	push	ix
	pop	hl		; l1
	inc	hl
	inc	hl
	ld	a,(hl)
	inc	hl
	ld	h,(hl)
	ld	l,a
	ld	(iy-16),l
	ld	(iy-15),h		; i
; |>>> i1=*(((int *)&l2)+1);
	push	iy
	pop	hl
	dec	hl
	dec	hl
	dec	hl
	dec	hl		; addr. l2
	inc	hl
	inc	hl
	ld	a,(hl)
	inc	hl
	ld	h,(hl)
	ld	l,a
	ld	(iy-18),l
	ld	(iy-17),h		; i1
; |>>> if(i1>i)
	ld	l,(iy-16)
	ld	h,(iy-15)		; i
	ld	a,(iy-18)
	scf
	sbc	a,l
	ld	a,(iy-17)
	sbc	a,h
	jp	m,L00260
; |>>> i=i1;                // pre|
	ld	l,(iy-18)
	ld	h,(iy-17)		; i1
	ld	(iy-16),l
	ld	(iy-15),h		; i
L00260:
; |>>> j=strncmp(p,p1,i);
	ld	l,(iy-16)
	ld	h,(iy-15)		; i
	push	hl
	ld	l,(iy-14)
	ld	h,(iy-13)		; p1
	push	hl
	ld	l,(iy-12)
	ld	h,(iy-11)		; p
	push	hl
	call	_strncmp
	pop	af
	pop	af
	pop	af
	ld	a,l
	sla	a
	sbc	a,a
	ld	h,a
	ld	(iy-20),l
	ld	(iy-19),h		; j
; |>>> switch(ch) {
	ld	l,(iy-6)		; ch
	ld	a,l
	cp	60
	jp	z,J00261_3c
	cp	61
	jp	z,J00261_3d
	cp	62
	jp	z,J00261_3e
	jp	J00261
; |>>> case '<':
J00261_3c:
; |>>> if(!i)
	ld	a,(iy-16)
	or	(iy-15)		; i
	jp	nz,L00262
; |>>> *l1=j <= 0 ? 1 : 0;
	ld	a,(iy-19)
	sub	0
	jr	z,$+5
	jp	p,L00263
	ld	de,1
	jr	L00263_
L00263:
	ld	de,0
L00263_:
	ld	a,d
	sla	a
	sbc	a,a
	ld	c,a
	ld	b,c
	ld	(ix+0),e
	ld	(ix+1),d
	ld	(ix+2),c
	ld	(ix+3),b
	jp	E00262
L00262:
; |>>> else {
; |>>> if(i>0)
	ld	a,(iy-15)
	sub	0
	jp	m,L00264
	jp	z,L00264
; |>>> *l1=j < 0 ? 1 : 0;
	bit	7,(iy-19)
	jp	z,L00265
	ld	de,1
	jr	L00265_
L00265:
	ld	de,0
L00265_:
	ld	a,d
	sla	a
	sbc	a,a
	ld	c,a
	ld	b,c
	ld	(ix+0),e
	ld	(ix+1),d
	ld	(ix+2),c
	ld	(ix+3),b
	jp	E00264
L00264:
; |>>> else
; |>>> *l1=j != 0;
	ld	a,(iy-20)
	or	(iy-19)
	jp	z,L00266
	ld	e,1
	jr	J00267
L00266:
	ld	e,0
J00267:
	ld	d,0
	ld	(ix+0),e
	ld	(ix+1),d
	ld	(ix+2),c
	ld	(ix+3),b
E00264:
E00262:
; |>>> break;
	jp	J00261
; |>>> case '=':
J00261_3d:
; |>>> *l1=j == 0;
	ld	a,(iy-20)
	or	(iy-19)
	jp	nz,L00268
	ld	e,1
	jr	J00269
L00268:
	ld	e,0
J00269:
	ld	d,0
	ld	(ix+0),e
	ld	(ix+1),d
	ld	(ix+2),c
	ld	(ix+3),b
; |>>> break;
	jp	J00261
; |>>> case '>':
J00261_3e:
; |>>> if(i)
	ld	a,(iy-16)
	or	(iy-15)		; i
	jp	z,L00270
; |>>> *l1=j >= 0 ? 1 : 0;
	bit	7,(iy-19)
	jp	nz,L00271
	ld	de,1
	jr	L00271_
L00271:
	ld	de,0
L00271_:
	ld	a,d
	sla	a
	sbc	a,a
	ld	c,a
	ld	b,c
	ld	(ix+0),e
	ld	(ix+1),d
	ld	(ix+2),c
	ld	(ix+3),b
	jp	E00270
L00270:
; |>>> else
; |>>> *l1=j > 0 ? 1 : 0;
	ld	a,(iy-19)
	sub	0
	jp	m,L00272
	jp	z,L00272
	ld	de,1
	jr	L00272_
L00272:
	ld	de,0
L00272_:
	ld	a,d
	sla	a
	sbc	a,a
	ld	c,a
	ld	b,c
	ld	(ix+0),e
	ld	(ix+1),d
	ld	(ix+2),c
	ld	(ix+3),b
E00270:
; |>>> break;
	jp	J00261
J00261:
; |>>> *f1=1;
	ld	l,(iy+8)
	ld	h,(iy+9)		; f1
	ld	(hl),1
; |>>> else
	jp	E00259
L00259:
; |>>> fError=4;
	ld	l,4
	ld	a,l
	ld	(_fError),a		; fError
E00259:
; |>>> else {
	jp	E00258
L00258:
; |>>> switch(ch) {
	ld	l,(iy-6)		; ch
	ld	a,l
	cp	60
	jp	z,J00273_3c
	cp	61
	jp	z,J00273_3d
	cp	62
	jp	z,J00273_3e
	jp	J00273
; |>>> case '<':
J00273_3c:
; |>>> if(!i)
	ld	a,(iy-16)
	or	(iy-15)		; i
	jp	nz,L00274
; |>>> *l1=*l1 < l2;
	ld	e,(ix+0)
	ld	d,(ix+1)
	ld	c,(ix+2)
	ld	b,(ix+3)
	push	de
	push	bc
	ld	e,(iy-4)
	ld	d,(iy-3)
	ld	c,(iy-2)
	ld	b,(iy-1)		; l2
	ld	(iy-24),e
	ld	(iy-23),d
	ld	(iy-22),c
	ld	(iy-21),b
	pop	bc
	pop	de
	ld	a,e
	sub	(iy-24)
	ld	a,d
	sbc	a,(iy-23)
	ld	a,c
	sbc	a,(iy-22)
	ld	a,b
	sbc	a,(iy-21)
	jp	p,L00275
	ld	e,1
	jr	J00276
L00275:
	ld	e,0
J00276:
	ld	d,0
	ld	(ix+0),e
	ld	(ix+1),d
	ld	(ix+2),c
	ld	(ix+3),b
	jp	E00274
L00274:
; |>>> else {
; |>>> if(i>0) 
	ld	a,(iy-15)
	sub	0
	jp	m,L00277
	jp	z,L00277
; |>>> *l1=*l1 <= l2;
	ld	e,(ix+0)
	ld	d,(ix+1)
	ld	c,(ix+2)
	ld	b,(ix+3)
	push	de
	push	bc
	ld	e,(iy-4)
	ld	d,(iy-3)
	ld	c,(iy-2)
	ld	b,(iy-1)		; l2
	ld	(iy-24),e
	ld	(iy-23),d
	ld	(iy-22),c
	ld	(iy-21),b
	pop	bc
	pop	de
	ld	a,e
	scf
	sbc	a,(iy-24)
	ld	a,d
	sbc	a,(iy-23)
	ld	a,c
	sbc	a,(iy-22)
	ld	a,b
	sbc	a,(iy-21)
	jp	p,L00278
	ld	e,1
	jr	J00279
L00278:
	ld	e,0
J00279:
	ld	d,0
	ld	(ix+0),e
	ld	(ix+1),d
	ld	(ix+2),c
	ld	(ix+3),b
	jp	E00277
L00277:
; |>>> else
; |>>> *l1=*l1 != l2;
	ld	e,(ix+0)
	ld	d,(ix+1)
	ld	c,(ix+2)
	ld	b,(ix+3)
	push	de
	push	bc
	ld	e,(iy-4)
	ld	d,(iy-3)
	ld	c,(iy-2)
	ld	b,(iy-1)		; l2
	ld	(iy-24),e
	ld	(iy-23),d
	ld	(iy-22),c
	ld	(iy-21),b
	pop	bc
	pop	de
	ld	a,e
	cp	(iy-24)
	jr	nz,J00280
	ld	a,d
	cp	c
	jr	nz,J00280
	ld	a,c
	cp	(iy-22)
	jr	nz,J00280
	ld	a,b
	cp	(iy-21)
J00280:
	jp	z,L00281
	ld	e,1
	jr	J00282
L00281:
	ld	e,0
J00282:
	ld	d,0
	ld	(ix+0),e
	ld	(ix+1),d
	ld	(ix+2),c
	ld	(ix+3),b
E00277:
E00274:
; |>>> break;
	jp	J00273
; |>>> case '=':
J00273_3d:
; |>>> *l1=*l1 == l2;
	ld	e,(ix+0)
	ld	d,(ix+1)
	ld	c,(ix+2)
	ld	b,(ix+3)
	push	de
	push	bc
	ld	e,(iy-4)
	ld	d,(iy-3)
	ld	c,(iy-2)
	ld	b,(iy-1)		; l2
	ld	(iy-24),e
	ld	(iy-23),d
	ld	(iy-22),c
	ld	(iy-21),b
	pop	bc
	pop	de
	ld	a,e
	cp	(iy-24)
	jr	nz,J00283
	ld	a,d
	cp	c
	jr	nz,J00283
	ld	a,c
	cp	(iy-22)
	jr	nz,J00283
	ld	a,b
	cp	(iy-21)
J00283:
	jp	nz,L00284
	ld	e,1
	jr	J00285
L00284:
	ld	e,0
J00285:
	ld	d,0
	ld	(ix+0),e
	ld	(ix+1),d
	ld	(ix+2),c
	ld	(ix+3),b
; |>>> break;
	jp	J00273
; |>>> case '>':
J00273_3e:
; |>>> if(i)
	ld	a,(iy-16)
	or	(iy-15)		; i
	jp	z,L00286
; |>>> *l1=*l1 >= l2;
	ld	e,(ix+0)
	ld	d,(ix+1)
	ld	c,(ix+2)
	ld	b,(ix+3)
	push	de
	push	bc
	ld	e,(iy-4)
	ld	d,(iy-3)
	ld	c,(iy-2)
	ld	b,(iy-1)		; l2
	ld	(iy-24),e
	ld	(iy-23),d
	ld	(iy-22),c
	ld	(iy-21),b
	pop	bc
	pop	de
	ld	a,e
	sub	(iy-24)
	ld	a,d
	sbc	a,(iy-23)
	ld	a,c
	sbc	a,(iy-22)
	ld	a,b
	sbc	a,(iy-21)
	jp	m,L00287
	ld	e,1
	jr	J00288
L00287:
	ld	e,0
J00288:
	ld	d,0
	ld	(ix+0),e
	ld	(ix+1),d
	ld	(ix+2),c
	ld	(ix+3),b
	jp	E00286
L00286:
; |>>> else
; |>>> *l1=*l1 > l2;
	ld	e,(ix+0)
	ld	d,(ix+1)
	ld	c,(ix+2)
	ld	b,(ix+3)
	push	de
	push	bc
	ld	e,(iy-4)
	ld	d,(iy-3)
	ld	c,(iy-2)
	ld	b,(iy-1)		; l2
	ld	(iy-24),e
	ld	(iy-23),d
	ld	(iy-22),c
	ld	(iy-21),b
	pop	bc
	pop	de
	ld	a,e
	scf
	sbc	a,(iy-24)
	ld	a,d
	sbc	a,(iy-23)
	ld	a,c
	sbc	a,(iy-22)
	ld	a,b
	sbc	a,(iy-21)
	jp	m,L00289
	ld	e,1
	jr	J00290
L00289:
	ld	e,0
J00290:
	ld	d,0
	ld	(ix+0),e
	ld	(ix+1),d
	ld	(ix+2),c
	ld	(ix+3),b
E00286:
; |>>> break;
	jp	J00273
J00273:
E00258:
; |>>> else
	jp	E00255
L00255:
; |>>> Go=1;
	ld	(iy-7),1		; Go
E00255:
; |>>> break;
	jp	J00240
; |>>> case '\xc0':               |
J00240_c0:
; |>>> case '\xc1':
J00240_c1:
; |>>> if(Pty >= 7) {
	ld	a,(iy+4)
	cp	7
	jp	m,L00291
; |>>> TextP++;
	ld	hl,(_TextP)
	inc	hl
	ld	(_TextP),hl
; |>>> RecursEval(6,&l2,&f2);
	push	iy
	pop	hl
	ld	a,l
	sub	5
	ld	l,a
	ld	a,h
	sbc	a,0
	ld	h,a		; addr. f2
	push	hl
	push	iy
	pop	hl
	dec	hl
	dec	hl
	dec	hl
	dec	hl		; addr. l2
	push	hl
	ld	l,6
	push	hl
	call	_RecursEval
	pop	af
	pop	af
	pop	af
; |>>> if((*f1 & 2) || (f2 & 2)) {|
	ld	l,(iy+8)
	ld	h,(iy+9)		; f1
	ld	l,(hl)
	ld	a,l
	and	2
	ld	l,a
	ld	a,l
	or	a
	jp	nz,L00293
	bit	1,(iy-5)
	jp	z,L00292
L00293:
; |>>> fError=4;
	ld	l,4
	ld	a,l
	ld	(_fError),a		; fError
; |>>> else {
	jp	E00292
L00292:
; |>>> if(ch=='\xc0')
	ld	a,(iy-6)
	cp	192
	jp	nz,L00294
; |>>> *l1=(*(int *)l1) & ((int)l2|
	push	ix
	pop	de		; l1
	ld	c,(iy-4)
	ld	b,(iy-3)		; l2
	ld	a,(de)
	inc	de
	push	af
	ld	a,(de)
	ld	d,a
	pop	af
	ld	e,a
	ld	a,e
	and	c
	ld	e,a
	ld	a,d
	and	b
	ld	d,a
	ld	a,d
	sla	a
	sbc	a,a
	ld	c,a
	ld	b,c
	ld	(ix+0),e
	ld	(ix+1),d
	ld	(ix+2),c
	ld	(ix+3),b
	jp	E00294
L00294:
; |>>> else
; |>>> *l1=(*(int *)l1) | ((int)l2|
	push	ix
	pop	de		; l1
	ld	c,(iy-4)
	ld	b,(iy-3)		; l2
	ld	a,(de)
	inc	de
	push	af
	ld	a,(de)
	ld	d,a
	pop	af
	ld	e,a
	ld	a,e
	or	c
	ld	e,a
	ld	a,d
	or	b
	ld	d,a
	ld	a,d
	sla	a
	sbc	a,a
	ld	c,a
	ld	b,c
	ld	(ix+0),e
	ld	(ix+1),d
	ld	(ix+2),c
	ld	(ix+3),b
E00294:
; |>>> *f1=1;  
	ld	l,(iy+8)
	ld	h,(iy+9)		; f1
	ld	(hl),1
E00292:
; |>>> else
	jp	E00291
L00291:
; |>>> Go=1;
	ld	(iy-7),1		; Go
E00291:
; |>>> break;
	jp	J00240
; |>>> case ' ':
J00240_20:
; |>>> TextP++;
	ld	hl,(_TextP)
	inc	hl
	ld	(_TextP),hl
; |>>> Times--;
	dec	(iy-9)
; |>>> break;
	jp	J00240
; |>>> case 0:
J00240_0:
; |>>> case ':':
J00240_3a:
; |>>> case ';':
J00240_3b:
; |>>> case ',':
J00240_2c:
; |>>> case '\x91':               |
J00240_91:
; |>>> case '\x90':
J00240_90:
; |>>> case '\x8c':
J00240_8c:
; |>>> case '\x8d':
J00240_8d:
; |>>> case '\x89':
J00240_89:
; |>>> case '\x8a':
J00240_8a:
; |>>> Go=1;
	ld	(iy-7),1		; Go
; |>>> break;
	jp	J00240
; |>>> default:
J00240_:
; |>>> *f1=GetAritmElem(l1);
	ld	l,(iy+8)
	ld	h,(iy+9)		; f1
	push	hl
	push	ix
	call	_GetAritmElem
	pop	af
	ld	e,l
	pop	hl
	ld	(hl),e
; |>>> break;
	jp	J00240
J00240:
; |>>> Times++;
	inc	(iy-9)
; |>>> while(!Go && !fError);
J00239_1:
	ld	a,(iy-7)		; Go
	or	a
	jp	nz,J00239_
	ld	a,(_fError)		; fError
	or	a
	jp	nz,J00239_
	jp	J00239
J00239_:
; |>>> return 0;
	xor	a
	ld	l,a
	jp	R00295
R00295:
	pop	ix
	ld	sp,iy
	pop	iy
	ret
_RecursEval	endp
; --------------------------------}

; |--- long EvalExpr(char Pty, cha|

public	_EvalExpr
_EvalExpr	proc
	push	iy
	ld	iy,0
	add	iy,sp
	push	af
	push	af
; Pty = 4
; flags = 6
; |--- long l;
; l = -4
; --------------------------------|
; |>>> RecursEval(Pty,&l,flags);
	ld	l,(iy+6)
	ld	h,(iy+7)		; flags
	push	hl
	push	iy
	pop	hl
	dec	hl
	dec	hl
	dec	hl
	dec	hl		; addr. l
	push	hl
	ld	l,(iy+4)		; Pty
	push	hl
	call	_RecursEval
	pop	af
	pop	af
	pop	af
; |>>> return l;
	ld	l,(iy-4)
	ld	h,(iy-3)
	ld	e,(iy-2)
	ld	d,(iy-1)		; l
	jp	R00296
R00296:
	ld	sp,iy
	pop	iy
	ret
_EvalExpr	endp
; --------------------------------}

; |--- long GetValue(char m) {    |

public	_GetValue
_GetValue	proc
	push	iy
	ld	iy,0
	add	iy,sp
	push	af
	push	af
	push	af
; m = 4
; |--- char flags=-1;
; flags = -1
	ld	(iy-1),255		; flags
; |--- long l;
; l = -5
; --------------------------------|
; |>>> l=EvalExpr(15,&flags);
	push	iy
	pop	hl
	dec	hl		; addr. flags
	push	hl
	ld	l,15
	push	hl
	call	_EvalExpr
	pop	af
	pop	af
	ld	(iy-5),l
	ld	(iy-4),h
	ld	(iy-3),e
	ld	(iy-2),d		; l
; |>>> if(flags<0)
	ld	a,(iy-1)
	or	a
	jp	p,L00297
; |>>> fError=1;
	ld	l,1
	ld	a,l
	ld	(_fError),a		; fError
	jp	E00297
L00297:
; |>>> else { 
; |>>> if(m) {
	ld	a,(iy+4)		; m
	or	a
	jp	z,L00298
; |>>> if(!(flags & 2)) {
	bit	1,(iy-1)
	jp	nz,L00299
; |>>> fError=4;
	ld	l,4
	ld	a,l
	ld	(_fError),a		; fError
L00299:
; |>>> else {
	jp	E00298
L00298:
; |>>> if(flags & 2) {
	bit	1,(iy-1)
	jp	z,L00300
; |>>> fError=4;
	ld	l,4
	ld	a,l
	ld	(_fError),a		; fError
L00300:
E00298:
E00297:
; |>>> return l;
	ld	l,(iy-5)
	ld	h,(iy-4)
	ld	e,(iy-3)
	ld	d,(iy-2)		; l
	jp	R00301
R00301:
	ld	sp,iy
	pop	iy
	ret
_GetValue	endp
; --------------------------------}

; |--- int DoError(char n) {

public	_DoError
_DoError	proc
	push	iy
	ld	iy,0
	add	iy,sp
; n = 4
; --------------------------------|
; |>>> putch('?');
	ld	l,63
	push	hl
	call	_putch
	pop	af
; |>>> printf(Errore[n-1]);
	ld	e,(iy+4)		; n
	dec	e
	ld	hl,_Errore		; addr. Errore
	ld	d,0
	sla	e
	rl	d
	add	hl,de
	ld	a,(hl)
	inc	hl
	ld	h,(hl)
	ld	l,a
	push	hl
	call	_printf
	pop	af
; |>>> if(!DirectMode) {
	ld	a,(_DirectMode)		; DirectMode
	or	a
	jp	nz,L00302
; |>>> printf(" alla linea %u\n",L}
	ld	hl,(_Linea)		; Linea
	push	hl
	ld	hl,L00303
	push	hl
	call	_printf
	pop	af
	pop	af
; |>>> else {
	jp	E00302
L00302:
E00302:
	pop	iy
	ret
_DoError	endp
; --------------------------------}

; |--- void SkipSpaces() {

public	_SkipSpaces
_SkipSpaces	proc
; |>>> while(*TextP == ' ')
J00304_:
	ld	hl,(_TextP)		; TextP
	ld	l,(hl)
	ld	a,l
	cp	32
	jp	nz,J00304
; |>>> TextP++;
	ld	hl,(_TextP)
	inc	hl
	ld	(_TextP),hl
	jp 	J00304_
J00304:
	ret
_SkipSpaces	endp
; --------------------------------}

; |--- char DoCheck(char ch) {

public	_DoCheck
_DoCheck	proc
	push	iy
	ld	iy,0
	add	iy,sp
; ch = 4
; --------------------------------|
; |>>> SkipSpaces();
	call	_SkipSpaces
; |>>> if(ch==*TextP) {
	ld	hl,(_TextP)		; TextP
	ld	l,(hl)
	ld	a,(iy+4)
	cp	l
	jp	nz,L00305
; |>>> TextP++;
	ld	hl,(_TextP)
	inc	hl
	ld	(_TextP),hl
; |>>> return 0;
	xor	a
	ld	l,a
	jp	R00306
; |>>> else {
	jp	E00305
L00305:
; |>>> fError=1;
	ld	l,1
	ld	a,l
	ld	(_fError),a		; fError
; |>>> return 1;
	ld	l,1
	jp	R00306
E00305:
R00306:
	pop	iy
	ret
_DoCheck	endp
; --------------------------------}

; |--- char CheckMemory(int n) {

public	_CheckMemory
_CheckMemory	proc
	push	iy
	ld	iy,0
	add	iy,sp
	push	af
; n = 4
; |--- int i;
; i = -2
; --------------------------------|
; |>>> i=StrBase-VarEnd;
	ld	hl,(_StrBase)		; StrBase
	ld	de,(_VarEnd)		; VarEnd
	or	a
	sbc	hl,de
	ld	(iy-2),l
	ld	(iy-1),h		; i
; |>>> if(i<n) {
	ld	l,(iy+4)
	ld	h,(iy+5)		; n
	ld	a,(iy-2)
	sub	l
	ld	a,(iy-1)
	sbc	a,h
	jp	p,L00307
; |>>> fError=7;
	ld	l,7
	ld	a,l
	ld	(_fError),a		; fError
; |>>> return 1;
	ld	l,1
	jp	R00308
; |>>> else
	jp	E00307
L00307:
; |>>> return 0;
	xor	a
	ld	l,a
	jp	R00308
E00307:
R00308:
	pop	af
	pop	iy
	ret
_CheckMemory	endp
; --------------------------------}

; |--- char *AllocaString(int n) {`

public	_AllocaString
_AllocaString	proc
	push	iy
	ld	iy,0
	add	iy,sp
; n = 4
; |>>> if(!CheckMemory(n)) {
	ld	l,(iy+4)
	ld	h,(iy+5)		; n
	push	hl
	call	_CheckMemory
	pop	af
	ld	e,l
	ld	a,l
	or	a
	jp	nz,L00309
; |>>> StrBase -= n;
	ld	hl,(_StrBase)		; StrBase
	ld	a,l
	sub	(iy+4)
	ld	l,a
	ld	a,h
	sbc	a,(iy+5)
	ld	h,a
	ld	(_StrBase),hl		; StrBase
; |>>> return StrBase;
	ld	hl,(_StrBase)		; StrBase
	jp	R00310
; |>>> else
	jp	E00309
L00309:
; |>>> return 0;
	ld	hl,0
	jp	R00310
E00309:
R00310:
	pop	iy
	ret
_AllocaString	endp
; --------------------------------}
	end
